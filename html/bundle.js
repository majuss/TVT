(function e(t, n, r) { function s(o, u) { if (!n[o]) { if (!t[o]) { var a = typeof require == "function" && require; if (!u && a) return a(o, !0); if (i) return i(o, !0); var f = new Error("Cannot find module '" + o + "'"); throw f.code = "MODULE_NOT_FOUND", f } var l = n[o] = { exports: {} }; t[o][0].call(l.exports, function (e) { var n = t[o][1][e]; return s(n ? n : e) }, l, l.exports, e, t, n, r) } return n[o].exports } var i = typeof require == "function" && require; for (var o = 0; o < r.length; o++)s(r[o]); return s })({


	1: [function (require, module, exports) {

		var twitchStreams = require('twitch-get-stream')('YOUR_API_KEY'); // twitch now ENFORCES client id usage apparently, so this is now required.

		getStreamFromChannel = function (channel) {
			return twitchStreams.get(channel);
		}

	}, { "twitch-get-stream": 2 }],


	2: [function (require, module, exports) {

		var Promise = require('promise');
		var request = require('superagent');
		var M3U = require('playlist-parser').M3U;
		var _compact = require('lodash.compact');

		var clid;

		// Some functions that help along the way
		// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/random
		// Returns a random integer between min (included) and max (included)
		// Using Math.round() will give you a non-uniform distribution!
		var getRandomIntInclusive = function (min, max) {
			return Math.floor(Math.random() * (max - min + 1)) + min;
		}

		// Thanks michaelowens, :)
		// Simple titlecase thing, capitalize first letter
		var titleCase = function (str) {
			return str.split(' ').map(function (word) { return word.charAt(0).toUpperCase() + word.slice(1).toLowerCase(); }).join(' ');
		}


		// Twitch functions
		var getAccessToken = function (channel) {
			// Get access token
			return new Promise(function (resolve, reject) {
				request
					.get('http://api.twitch.tv/api/channels/' + channel + '/access_token')
					.set({ 'Client-ID': clid })
					.end(function (err, res) {
						if (err) return reject(err);
						if (!res.ok) return reject(new Error('Could not access the twitch API to get the access token, maybe your internet or twitch is down.'));

						return resolve(res.body);
					});
			});
		}

		var getPlaylist = function (channel) {
			// Get the playlist with given access token data (parsed /access_token response)
			return new Promise(function (resolve, reject) {
				request
					.get('http://192.168.2.113:8002/' + channel)
					.end(function (err, res) {
						if (err) return reject(err);
						if (!res.ok) return reject(new Error('Could not access the twitch API to get the playlist, maybe your internet or twitch is down.'));
						console.log(res.text)
						return resolve(res.text);
					});
			});
		}

		// Exposed functions
		// Just get the playlist, return the string nothing else
		var getPlaylistOnly = function (channel) {
			if (!channel) return Promise.reject(new Error('No channel defined.'));

			var channel = channel.toLowerCase(); // Twitch API only takes lowercase
			return getPlaylist(channel);
		}

		// Above get playlist, but then parses it and gives the object
		var getPlaylistParsed = function (channel) {
			return getPlaylistOnly(channel)
				.then(function (data) {
					return Promise.resolve(_compact(M3U.parse(data)));
				});
		}

		var getStreamUrls = function (channel) { // This returns the one with a custom fully parsed object
			return getPlaylistParsed(channel)
				.then(function (playlist) {
					console.log(playlist)
					if (playlist.length < 1) return Promise.reject(new Error('There were no results, maybe the channel is offline?'));

					//Parse playlist with quality options and send to new array of objects
					var streamLinks = [];


					for (var i = 0; i < playlist.length; i++) {
						// Quality option
						// var name = playlist[i].title.match(/VIDEO=('|")(.*?)('|")/); // Raw quality name
						// name = name[2]; // Get regex captured group

						// Rename checks
						// chunked = source
						// if (name === 'chunked') name = 'source';
						// audio_only = Audio Only
						// else if (name === 'audio_only') name = 'audio only';

						// Resolution
						// var resMatch = playlist[i].title.match(/RESOLUTION=(.*?),/);
						// var res = resMatch ? resMatch[1] : null // Audio only does not have a res so we need this check

						streamLinks.push({
							quality: 'someName', // Title case the quality
							resolution: 'best',
							url: playlist[i].file
						});
					}
					console.log(streamLinks[0].url)
					return Promise.resolve(streamLinks);
				});
		}

		module.exports =
			function (clientid) {
				clid = clientid;
				return {
					get: Promise.nodeify(getStreamUrls),
					raw: Promise.nodeify(getPlaylistOnly),
					rawParsed: Promise.nodeify(getPlaylistParsed)
				};
			};
	}, { "lodash.compact": 3, "playlist-parser": 4, "promise": 8, "superagent": 18 }], 3: [function (require, module, exports) {
		/**
		 * lodash 3.0.1 (Custom Build) <https://lodash.com/>
		 * Build: `lodash modularize exports="npm" -o ./`
		 * Copyright 2012-2016 The Dojo Foundation <http://dojofoundation.org/>
		 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
		 * Copyright 2009-2016 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
		 * Available under MIT license <https://lodash.com/license>
		 */

		/**
		 * Creates an array with all falsey values removed. The values `false`, `null`,
		 * `0`, `""`, `undefined`, and `NaN` are falsey.
		 *
		 * @static
		 * @memberOf _
		 * @category Array
		 * @param {Array} array The array to compact.
		 * @returns {Array} Returns the new array of filtered values.
		 * @example
		 *
		 * _.compact([0, 1, false, 2, '', 3]);
		 * // => [1, 2, 3]
		 */
		function compact(array) {
			var index = -1,
				length = array ? array.length : 0,
				resIndex = 0,
				result = [];

			while (++index < length) {
				var value = array[index];
				if (value) {
					result[resIndex++] = value;
				}
			}
			return result;
		}

		module.exports = compact;

	}, {}], 4: [function (require, module, exports) {
		/*
		This software is dual licensed under the MIT and Beerware license.
		
		The MIT License (MIT)
		
		Copyright (c) 2013 Nick Desaulniers
		
		Permission is hereby granted, free of charge, to any person obtaining a copy of
		this software and associated documentation files (the "Software"), to deal in
		the Software without restriction, including without limitation the rights to
		use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
		the Software, and to permit persons to whom the Software is furnished to do so,
		subject to the following conditions:
		
		The above copyright notice and this permission notice shall be included in all
		copies or substantial portions of the Software.
		
		THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
		IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
		FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
		COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
		IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
		CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
		
		"THE BEER-WARE LICENSE" (Revision 42):
		<nick@mozilla.com> wrote this file. As long as you retain this
		notice you can do whatever you want with this stuff. If we meet some day,
		and you think this stuff is worth it, you can buy me a beer in return.
		Nick Desaulniers
		
		*/
		(function () { var a, b, c; a = ("undefined" != typeof window && null !== window ? window.DOMParser : void 0) || ("function" == typeof require ? require("xmldom").DOMParser : void 0) || function () { }, b = function (a, c) { var d, e, f, g, h, i, j, k, l, m, n; if (a.hasChildNodes()) for (g = a.childNodes, h = k = 0, m = g.length; m >= 0 ? m > k : k > m; h = m >= 0 ? ++k : --k)if (e = g[h], f = e.nodeName, /REF/i.test(f)) { for (d = e.attributes, j = l = 0, n = d.length; n >= 0 ? n > l : l > n; j = n >= 0 ? ++l : --l)if (i = d[j].nodeName.match(/HREF/i)) { c.push({ file: e.getAttribute(i[0]).trim() }); break } } else "#text" !== f && b(e, c); return null }, c = function (c) { var d, e; return e = [], (d = (new a).parseFromString(c, "text/xml").documentElement) ? (b(d, e), e) : e }, ("undefined" != typeof module && null !== module ? module.exports : window).ASX = { name: "asx", parse: c } }).call(this), function () { var a, b, c, d, e, f, g; b = "#EXTM3U", a = /:(?:(-?\d+),(.+)\s*-\s*(.+)|(.+))\n(.+)/, e = function (b) { var c; return c = b.match(a), c && 6 === c.length ? { length: c[1] || 0, artist: c[2] || "", title: c[4] || c[3], file: c[5].trim() } : void 0 }, g = function (a) { return { file: a.trim() } }, d = function (a) { return !!a.trim().length }, c = function (a) { return "#" !== a[0] }, f = function (a) { var f; return a = a.replace(/\r/g, ""), f = a.search("\n"), a.substr(0, f) === b ? a.substr(f).split("\n#").filter(d).map(e) : a.split("\n").filter(d).filter(c).map(g) }, ("undefined" != typeof module && null !== module ? module.exports : window).M3U = { name: "m3u", parse: f } }.call(this), function () { var a, b; a = /(file|title|length)(\d+)=(.+)\r?/i, b = function (b) { var c, d, e, f, g, h, i, j, k, l; for (g = [], l = b.trim().split("\n"), j = 0, k = l.length; k > j; j++)e = l[j], f = e.match(a), f && 4 === f.length && (i = f[0], d = f[1], c = f[2], h = f[3], g[c] || (g[c] = {}), g[c][d.toLowerCase()] = h); return g.filter(function (a) { return null != a }) }, ("undefined" != typeof module && null !== module ? module.exports : window).PLS = { name: "pls", parse: b } }.call(this);
	}, { "xmldom": 5 }], 5: [function (require, module, exports) {
		function DOMParser(options) {
			this.options =
				options != true && //To the version (0.1.12) compatible
				options || { locator: {} };

		}
		DOMParser.prototype.parseFromString = function (source, mimeType) {
			var sax = new XMLReader();
			var options = this.options;
			var domBuilder = options.domBuilder || new DOMHandler();//contentHandler and LexicalHandler
			var errorHandler = options.errorHandler;
			var locator = options.locator;
			var defaultNSMap = {};
			var entityMap = { 'lt': '<', 'gt': '>', 'amp': '&', 'quot': '"', 'apos': "'" }
			if (locator) {
				domBuilder.setDocumentLocator(locator)
			}

			sax.errorHandler = buildErrorHandler(errorHandler, domBuilder, locator);
			sax.domBuilder = options.domBuilder || domBuilder;
			if (/\/x?html?$/.test(mimeType)) {
				entityMap.nbsp = '\xa0';
				entityMap.copy = '\xa9';
				defaultNSMap[''] = 'http://www.w3.org/1999/xhtml';
			}
			sax.parse(source, defaultNSMap, entityMap);
			return domBuilder.document;
		}
		function buildErrorHandler(errorImpl, domBuilder, locator) {
			if (!errorImpl) {
				if (domBuilder instanceof DOMHandler) {
					return domBuilder;
				}
				errorImpl = domBuilder;
			}
			var errorHandler = {}
			var isCallback = errorImpl instanceof Function;
			locator = locator || {}
			function build(key) {
				var fn = errorImpl[key];
				if (!fn) {
					if (isCallback) {
						fn = errorImpl.length == 2 ? function (msg) { errorImpl(key, msg) } : errorImpl;
					} else {
						var i = arguments.length;
						while (--i) {
							if (fn = errorImpl[arguments[i]]) {
								break;
							}
						}
					}
				}
				errorHandler[key] = fn && function (msg) {
					fn(msg + _locator(locator));
				} || function () { };
			}
			build('warning', 'warn');
			build('error', 'warn', 'warning');
			build('fatalError', 'warn', 'warning', 'error');
			return errorHandler;
		}
		/**
		 * +ContentHandler+ErrorHandler
		 * +LexicalHandler+EntityResolver2
		 * -DeclHandler-DTDHandler 
		 * 
		 * DefaultHandler:EntityResolver, DTDHandler, ContentHandler, ErrorHandler
		 * DefaultHandler2:DefaultHandler,LexicalHandler, DeclHandler, EntityResolver2
		 * @link http://www.saxproject.org/apidoc/org/xml/sax/helpers/DefaultHandler.html
		 */
		function DOMHandler() {
			this.cdata = false;
		}
		function position(locator, node) {
			node.lineNumber = locator.lineNumber;
			node.columnNumber = locator.columnNumber;
		}
		/**
		 * @see org.xml.sax.ContentHandler#startDocument
		 * @link http://www.saxproject.org/apidoc/org/xml/sax/ContentHandler.html
		 */
		DOMHandler.prototype = {
			startDocument: function () {
				this.document = new DOMImplementation().createDocument(null, null, null);
				if (this.locator) {
					this.document.documentURI = this.locator.systemId;
				}
			},
			startElement: function (namespaceURI, localName, qName, attrs) {
				var doc = this.document;
				var el = doc.createElementNS(namespaceURI, qName || localName);
				var len = attrs.length;
				appendElement(this, el);
				this.currentElement = el;

				this.locator && position(this.locator, el)
				for (var i = 0; i < len; i++) {
					var namespaceURI = attrs.getURI(i);
					var value = attrs.getValue(i);
					var qName = attrs.getQName(i);
					var attr = doc.createAttributeNS(namespaceURI, qName);
					if (attr.getOffset) {
						position(attr.getOffset(1), attr)
					}
					attr.value = attr.nodeValue = value;
					el.setAttributeNode(attr)
				}
			},
			endElement: function (namespaceURI, localName, qName) {
				var current = this.currentElement
				var tagName = current.tagName;
				this.currentElement = current.parentNode;
			},
			startPrefixMapping: function (prefix, uri) {
			},
			endPrefixMapping: function (prefix) {
			},
			processingInstruction: function (target, data) {
				var ins = this.document.createProcessingInstruction(target, data);
				this.locator && position(this.locator, ins)
				appendElement(this, ins);
			},
			ignorableWhitespace: function (ch, start, length) {
			},
			characters: function (chars, start, length) {
				chars = _toString.apply(this, arguments)
				//console.log(chars)
				if (this.currentElement && chars) {
					if (this.cdata) {
						var charNode = this.document.createCDATASection(chars);
						this.currentElement.appendChild(charNode);
					} else {
						var charNode = this.document.createTextNode(chars);
						this.currentElement.appendChild(charNode);
					}
					this.locator && position(this.locator, charNode)
				}
			},
			skippedEntity: function (name) {
			},
			endDocument: function () {
				this.document.normalize();
			},
			setDocumentLocator: function (locator) {
				if (this.locator = locator) {// && !('lineNumber' in locator)){
					locator.lineNumber = 0;
				}
			},
			//LexicalHandler
			comment: function (chars, start, length) {
				chars = _toString.apply(this, arguments)
				var comm = this.document.createComment(chars);
				this.locator && position(this.locator, comm)
				appendElement(this, comm);
			},

			startCDATA: function () {
				//used in characters() methods
				this.cdata = true;
			},
			endCDATA: function () {
				this.cdata = false;
			},

			startDTD: function (name, publicId, systemId) {
				var impl = this.document.implementation;
				if (impl && impl.createDocumentType) {
					var dt = impl.createDocumentType(name, publicId, systemId);
					this.locator && position(this.locator, dt)
					appendElement(this, dt);
				}
			},
			/**
			 * @see org.xml.sax.ErrorHandler
			 * @link http://www.saxproject.org/apidoc/org/xml/sax/ErrorHandler.html
			 */
			warning: function (error) {
				console.warn(error, _locator(this.locator));
			},
			error: function (error) {
				console.error(error, _locator(this.locator));
			},
			fatalError: function (error) {
				console.error(error, _locator(this.locator));
				throw error;
			}
		}
		function _locator(l) {
			if (l) {
				return '\n@' + (l.systemId || '') + '#[line:' + l.lineNumber + ',col:' + l.columnNumber + ']'
			}
		}
		function _toString(chars, start, length) {
			if (typeof chars == 'string') {
				return chars.substr(start, length)
			} else {//java sax connect width xmldom on rhino(what about: "? && !(chars instanceof String)")
				if (chars.length >= start + length || start) {
					return new java.lang.String(chars, start, length) + '';
				}
				return chars;
			}
		}

		/*
		 * @link http://www.saxproject.org/apidoc/org/xml/sax/ext/LexicalHandler.html
		 * used method of org.xml.sax.ext.LexicalHandler:
		 *  #comment(chars, start, length)
		 *  #startCDATA()
		 *  #endCDATA()
		 *  #startDTD(name, publicId, systemId)
		 *
		 *
		 * IGNORED method of org.xml.sax.ext.LexicalHandler:
		 *  #endDTD()
		 *  #startEntity(name)
		 *  #endEntity(name)
		 *
		 *
		 * @link http://www.saxproject.org/apidoc/org/xml/sax/ext/DeclHandler.html
		 * IGNORED method of org.xml.sax.ext.DeclHandler
		 * 	#attributeDecl(eName, aName, type, mode, value)
		 *  #elementDecl(name, model)
		 *  #externalEntityDecl(name, publicId, systemId)
		 *  #internalEntityDecl(name, value)
		 * @link http://www.saxproject.org/apidoc/org/xml/sax/ext/EntityResolver2.html
		 * IGNORED method of org.xml.sax.EntityResolver2
		 *  #resolveEntity(String name,String publicId,String baseURI,String systemId)
		 *  #resolveEntity(publicId, systemId)
		 *  #getExternalSubset(name, baseURI)
		 * @link http://www.saxproject.org/apidoc/org/xml/sax/DTDHandler.html
		 * IGNORED method of org.xml.sax.DTDHandler
		 *  #notationDecl(name, publicId, systemId) {};
		 *  #unparsedEntityDecl(name, publicId, systemId, notationName) {};
		 */
		"endDTD,startEntity,endEntity,attributeDecl,elementDecl,externalEntityDecl,internalEntityDecl,resolveEntity,getExternalSubset,notationDecl,unparsedEntityDecl".replace(/\w+/g, function (key) {
			DOMHandler.prototype[key] = function () { return null }
		})

		/* Private static helpers treated below as private instance methods, so don't need to add these to the public API; we might use a Relator to also get rid of non-standard public properties */
		function appendElement(hander, node) {
			if (!hander.currentElement) {
				hander.document.appendChild(node);
			} else {
				hander.currentElement.appendChild(node);
			}
		}//appendChild and setAttributeNS are preformance key

		if (typeof require == 'function') {
			var XMLReader = require('./sax').XMLReader;
			var DOMImplementation = exports.DOMImplementation = require('./dom').DOMImplementation;
			exports.XMLSerializer = require('./dom').XMLSerializer;
			exports.DOMParser = DOMParser;
		}

	}, { "./dom": 6, "./sax": 7 }], 6: [function (require, module, exports) {
		/*
		 * DOM Level 2
		 * Object DOMException
		 * @see http://www.w3.org/TR/REC-DOM-Level-1/ecma-script-language-binding.html
		 * @see http://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/ecma-script-binding.html
		 */

		function copy(src, dest) {
			for (var p in src) {
				dest[p] = src[p];
			}
		}
		/**
		^\w+\.prototype\.([_\w]+)\s*=\s*((?:.*\{\s*?[\r\n][\s\S]*?^})|\S.*?(?=[;\r\n]));?
		^\w+\.prototype\.([_\w]+)\s*=\s*(\S.*?(?=[;\r\n]));?
		 */
		function _extends(Class, Super) {
			var pt = Class.prototype;
			if (Object.create) {
				var ppt = Object.create(Super.prototype)
				pt.__proto__ = ppt;
			}
			if (!(pt instanceof Super)) {
				function t() { };
				t.prototype = Super.prototype;
				t = new t();
				copy(pt, t);
				Class.prototype = pt = t;
			}
			if (pt.constructor != Class) {
				if (typeof Class != 'function') {
					console.error("unknow Class:" + Class)
				}
				pt.constructor = Class
			}
		}
		var htmlns = 'http://www.w3.org/1999/xhtml';
		// Node Types
		var NodeType = {}
		var ELEMENT_NODE = NodeType.ELEMENT_NODE = 1;
		var ATTRIBUTE_NODE = NodeType.ATTRIBUTE_NODE = 2;
		var TEXT_NODE = NodeType.TEXT_NODE = 3;
		var CDATA_SECTION_NODE = NodeType.CDATA_SECTION_NODE = 4;
		var ENTITY_REFERENCE_NODE = NodeType.ENTITY_REFERENCE_NODE = 5;
		var ENTITY_NODE = NodeType.ENTITY_NODE = 6;
		var PROCESSING_INSTRUCTION_NODE = NodeType.PROCESSING_INSTRUCTION_NODE = 7;
		var COMMENT_NODE = NodeType.COMMENT_NODE = 8;
		var DOCUMENT_NODE = NodeType.DOCUMENT_NODE = 9;
		var DOCUMENT_TYPE_NODE = NodeType.DOCUMENT_TYPE_NODE = 10;
		var DOCUMENT_FRAGMENT_NODE = NodeType.DOCUMENT_FRAGMENT_NODE = 11;
		var NOTATION_NODE = NodeType.NOTATION_NODE = 12;

		// ExceptionCode
		var ExceptionCode = {}
		var ExceptionMessage = {};
		var INDEX_SIZE_ERR = ExceptionCode.INDEX_SIZE_ERR = ((ExceptionMessage[1] = "Index size error"), 1);
		var DOMSTRING_SIZE_ERR = ExceptionCode.DOMSTRING_SIZE_ERR = ((ExceptionMessage[2] = "DOMString size error"), 2);
		var HIERARCHY_REQUEST_ERR = ExceptionCode.HIERARCHY_REQUEST_ERR = ((ExceptionMessage[3] = "Hierarchy request error"), 3);
		var WRONG_DOCUMENT_ERR = ExceptionCode.WRONG_DOCUMENT_ERR = ((ExceptionMessage[4] = "Wrong document"), 4);
		var INVALID_CHARACTER_ERR = ExceptionCode.INVALID_CHARACTER_ERR = ((ExceptionMessage[5] = "Invalid character"), 5);
		var NO_DATA_ALLOWED_ERR = ExceptionCode.NO_DATA_ALLOWED_ERR = ((ExceptionMessage[6] = "No data allowed"), 6);
		var NO_MODIFICATION_ALLOWED_ERR = ExceptionCode.NO_MODIFICATION_ALLOWED_ERR = ((ExceptionMessage[7] = "No modification allowed"), 7);
		var NOT_FOUND_ERR = ExceptionCode.NOT_FOUND_ERR = ((ExceptionMessage[8] = "Not found"), 8);
		var NOT_SUPPORTED_ERR = ExceptionCode.NOT_SUPPORTED_ERR = ((ExceptionMessage[9] = "Not supported"), 9);
		var INUSE_ATTRIBUTE_ERR = ExceptionCode.INUSE_ATTRIBUTE_ERR = ((ExceptionMessage[10] = "Attribute in use"), 10);
		//level2
		var INVALID_STATE_ERR = ExceptionCode.INVALID_STATE_ERR = ((ExceptionMessage[11] = "Invalid state"), 11);
		var SYNTAX_ERR = ExceptionCode.SYNTAX_ERR = ((ExceptionMessage[12] = "Syntax error"), 12);
		var INVALID_MODIFICATION_ERR = ExceptionCode.INVALID_MODIFICATION_ERR = ((ExceptionMessage[13] = "Invalid modification"), 13);
		var NAMESPACE_ERR = ExceptionCode.NAMESPACE_ERR = ((ExceptionMessage[14] = "Invalid namespace"), 14);
		var INVALID_ACCESS_ERR = ExceptionCode.INVALID_ACCESS_ERR = ((ExceptionMessage[15] = "Invalid access"), 15);


		function DOMException(code, message) {
			if (message instanceof Error) {
				var error = message;
			} else {
				error = this;
				Error.call(this, ExceptionMessage[code]);
				this.message = ExceptionMessage[code];
				if (Error.captureStackTrace) Error.captureStackTrace(this, DOMException);
			}
			error.code = code;
			if (message) this.message = this.message + ": " + message;
			return error;
		};
		DOMException.prototype = Error.prototype;
		copy(ExceptionCode, DOMException)
		/**
		 * @see http://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/core.html#ID-536297177
		 * The NodeList interface provides the abstraction of an ordered collection of nodes, without defining or constraining how this collection is implemented. NodeList objects in the DOM are live.
		 * The items in the NodeList are accessible via an integral index, starting from 0.
		 */
		function NodeList() {
		};
		NodeList.prototype = {
			/**
			 * The number of nodes in the list. The range of valid child node indices is 0 to length-1 inclusive.
			 * @standard level1
			 */
			length: 0,
			/**
			 * Returns the indexth item in the collection. If index is greater than or equal to the number of nodes in the list, this returns null.
			 * @standard level1
			 * @param index  unsigned long 
			 *   Index into the collection.
			 * @return Node
			 * 	The node at the indexth position in the NodeList, or null if that is not a valid index. 
			 */
			item: function (index) {
				return this[index] || null;
			}
		};
		function LiveNodeList(node, refresh) {
			this._node = node;
			this._refresh = refresh
			_updateLiveList(this);
		}
		function _updateLiveList(list) {
			var inc = list._node._inc || list._node.ownerDocument._inc;
			if (list._inc != inc) {
				var ls = list._refresh(list._node);
				//console.log(ls.length)
				__set__(list, 'length', ls.length);
				copy(ls, list);
				list._inc = inc;
			}
		}
		LiveNodeList.prototype.item = function (i) {
			_updateLiveList(this);
			return this[i];
		}

		_extends(LiveNodeList, NodeList);
		/**
		 * 
		 * Objects implementing the NamedNodeMap interface are used to represent collections of nodes that can be accessed by name. Note that NamedNodeMap does not inherit from NodeList; NamedNodeMaps are not maintained in any particular order. Objects contained in an object implementing NamedNodeMap may also be accessed by an ordinal index, but this is simply to allow convenient enumeration of the contents of a NamedNodeMap, and does not imply that the DOM specifies an order to these Nodes.
		 * NamedNodeMap objects in the DOM are live.
		 * used for attributes or DocumentType entities 
		 */
		function NamedNodeMap() {
		};

		function _findNodeIndex(list, node) {
			var i = list.length;
			while (i--) {
				if (list[i] === node) { return i }
			}
		}

		function _addNamedNode(el, list, newAttr, oldAttr) {
			if (oldAttr) {
				list[_findNodeIndex(list, oldAttr)] = newAttr;
			} else {
				list[list.length++] = newAttr;
			}
			if (el) {
				newAttr.ownerElement = el;
				var doc = el.ownerDocument;
				if (doc) {
					oldAttr && _onRemoveAttribute(doc, el, oldAttr);
					_onAddAttribute(doc, el, newAttr);
				}
			}
		}
		function _removeNamedNode(el, list, attr) {
			var i = _findNodeIndex(list, attr);
			if (i >= 0) {
				var lastIndex = list.length - 1
				while (i < lastIndex) {
					list[i] = list[++i]
				}
				list.length = lastIndex;
				if (el) {
					var doc = el.ownerDocument;
					if (doc) {
						_onRemoveAttribute(doc, el, attr);
						attr.ownerElement = null;
					}
				}
			} else {
				throw DOMException(NOT_FOUND_ERR, new Error())
			}
		}
		NamedNodeMap.prototype = {
			length: 0,
			item: NodeList.prototype.item,
			getNamedItem: function (key) {
				//		if(key.indexOf(':')>0 || key == 'xmlns'){
				//			return null;
				//		}
				var i = this.length;
				while (i--) {
					var attr = this[i];
					if (attr.nodeName == key) {
						return attr;
					}
				}
			},
			setNamedItem: function (attr) {
				var el = attr.ownerElement;
				if (el && el != this._ownerElement) {
					throw new DOMException(INUSE_ATTRIBUTE_ERR);
				}
				var oldAttr = this.getNamedItem(attr.nodeName);
				_addNamedNode(this._ownerElement, this, attr, oldAttr);
				return oldAttr;
			},
			/* returns Node */
			setNamedItemNS: function (attr) {// raises: WRONG_DOCUMENT_ERR,NO_MODIFICATION_ALLOWED_ERR,INUSE_ATTRIBUTE_ERR
				var el = attr.ownerElement, oldAttr;
				if (el && el != this._ownerElement) {
					throw new DOMException(INUSE_ATTRIBUTE_ERR);
				}
				oldAttr = this.getNamedItemNS(attr.namespaceURI, attr.localName);
				_addNamedNode(this._ownerElement, this, attr, oldAttr);
				return oldAttr;
			},

			/* returns Node */
			removeNamedItem: function (key) {
				var attr = this.getNamedItem(key);
				_removeNamedNode(this._ownerElement, this, attr);
				return attr;


			},// raises: NOT_FOUND_ERR,NO_MODIFICATION_ALLOWED_ERR

			//for level2
			removeNamedItemNS: function (namespaceURI, localName) {
				var attr = this.getNamedItemNS(namespaceURI, localName);
				_removeNamedNode(this._ownerElement, this, attr);
				return attr;
			},
			getNamedItemNS: function (namespaceURI, localName) {
				var i = this.length;
				while (i--) {
					var node = this[i];
					if (node.localName == localName && node.namespaceURI == namespaceURI) {
						return node;
					}
				}
				return null;
			}
		};
		/**
		 * @see http://www.w3.org/TR/REC-DOM-Level-1/level-one-core.html#ID-102161490
		 */
		function DOMImplementation(/* Object */ features) {
			this._features = {};
			if (features) {
				for (var feature in features) {
					this._features = features[feature];
				}
			}
		};

		DOMImplementation.prototype = {
			hasFeature: function (/* string */ feature, /* string */ version) {
				var versions = this._features[feature.toLowerCase()];
				if (versions && (!version || version in versions)) {
					return true;
				} else {
					return false;
				}
			},
			// Introduced in DOM Level 2:
			createDocument: function (namespaceURI, qualifiedName, doctype) {// raises:INVALID_CHARACTER_ERR,NAMESPACE_ERR,WRONG_DOCUMENT_ERR
				var doc = new Document();
				doc.doctype = doctype;
				if (doctype) {
					doc.appendChild(doctype);
				}
				doc.implementation = this;
				doc.childNodes = new NodeList();
				if (qualifiedName) {
					var root = doc.createElementNS(namespaceURI, qualifiedName);
					doc.appendChild(root);
				}
				return doc;
			},
			// Introduced in DOM Level 2:
			createDocumentType: function (qualifiedName, publicId, systemId) {// raises:INVALID_CHARACTER_ERR,NAMESPACE_ERR
				var node = new DocumentType();
				node.name = qualifiedName;
				node.nodeName = qualifiedName;
				node.publicId = publicId;
				node.systemId = systemId;
				// Introduced in DOM Level 2:
				//readonly attribute DOMString        internalSubset;

				//TODO:..
				//  readonly attribute NamedNodeMap     entities;
				//  readonly attribute NamedNodeMap     notations;
				return node;
			}
		};


		/**
		 * @see http://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/core.html#ID-1950641247
		 */

		function Node() {
		};

		Node.prototype = {
			firstChild: null,
			lastChild: null,
			previousSibling: null,
			nextSibling: null,
			attributes: null,
			parentNode: null,
			childNodes: null,
			ownerDocument: null,
			nodeValue: null,
			namespaceURI: null,
			prefix: null,
			localName: null,
			// Modified in DOM Level 2:
			insertBefore: function (newChild, refChild) {//raises 
				return _insertBefore(this, newChild, refChild);
			},
			replaceChild: function (newChild, oldChild) {//raises 
				this.insertBefore(newChild, oldChild);
				if (oldChild) {
					this.removeChild(oldChild);
				}
			},
			removeChild: function (oldChild) {
				return _removeChild(this, oldChild);
			},
			appendChild: function (newChild) {
				return this.insertBefore(newChild, null);
			},
			hasChildNodes: function () {
				return this.firstChild != null;
			},
			cloneNode: function (deep) {
				return cloneNode(this.ownerDocument || this, this, deep);
			},
			// Modified in DOM Level 2:
			normalize: function () {
				var child = this.firstChild;
				while (child) {
					var next = child.nextSibling;
					if (next && next.nodeType == TEXT_NODE && child.nodeType == TEXT_NODE) {
						this.removeChild(next);
						child.appendData(next.data);
					} else {
						child.normalize();
						child = next;
					}
				}
			},
			// Introduced in DOM Level 2:
			isSupported: function (feature, version) {
				return this.ownerDocument.implementation.hasFeature(feature, version);
			},
			// Introduced in DOM Level 2:
			hasAttributes: function () {
				return this.attributes.length > 0;
			},
			lookupPrefix: function (namespaceURI) {
				var el = this;
				while (el) {
					var map = el._nsMap;
					//console.dir(map)
					if (map) {
						for (var n in map) {
							if (map[n] == namespaceURI) {
								return n;
							}
						}
					}
					el = el.nodeType == 2 ? el.ownerDocument : el.parentNode;
				}
				return null;
			},
			// Introduced in DOM Level 3:
			lookupNamespaceURI: function (prefix) {
				var el = this;
				while (el) {
					var map = el._nsMap;
					//console.dir(map)
					if (map) {
						if (prefix in map) {
							return map[prefix];
						}
					}
					el = el.nodeType == 2 ? el.ownerDocument : el.parentNode;
				}
				return null;
			},
			// Introduced in DOM Level 3:
			isDefaultNamespace: function (namespaceURI) {
				var prefix = this.lookupPrefix(namespaceURI);
				return prefix == null;
			}
		};


		function _xmlEncoder(c) {
			return c == '<' && '&lt;' ||
				c == '>' && '&gt;' ||
				c == '&' && '&amp;' ||
				c == '"' && '&quot;' ||
				'&#' + c.charCodeAt() + ';'
		}


		copy(NodeType, Node);
		copy(NodeType, Node.prototype);

		/**
		 * @param callback return true for continue,false for break
		 * @return boolean true: break visit;
		 */
		function _visitNode(node, callback) {
			if (callback(node)) {
				return true;
			}
			if (node = node.firstChild) {
				do {
					if (_visitNode(node, callback)) { return true }
				} while (node = node.nextSibling)
			}
		}



		function Document() {
		}
		function _onAddAttribute(doc, el, newAttr) {
			doc && doc._inc++;
			var ns = newAttr.namespaceURI;
			if (ns == 'http://www.w3.org/2000/xmlns/') {
				//update namespace
				el._nsMap[newAttr.prefix ? newAttr.localName : ''] = newAttr.value
			}
		}
		function _onRemoveAttribute(doc, el, newAttr, remove) {
			doc && doc._inc++;
			var ns = newAttr.namespaceURI;
			if (ns == 'http://www.w3.org/2000/xmlns/') {
				//update namespace
				delete el._nsMap[newAttr.prefix ? newAttr.localName : '']
			}
		}
		function _onUpdateChild(doc, el, newChild) {
			if (doc && doc._inc) {
				doc._inc++;
				//update childNodes
				var cs = el.childNodes;
				if (newChild) {
					cs[cs.length++] = newChild;
				} else {
					//console.log(1)
					var child = el.firstChild;
					var i = 0;
					while (child) {
						cs[i++] = child;
						child = child.nextSibling;
					}
					cs.length = i;
				}
			}
		}

		/**
		 * attributes;
		 * children;
		 * 
		 * writeable properties:
		 * nodeValue,Attr:value,CharacterData:data
		 * prefix
		 */
		function _removeChild(parentNode, child) {
			var previous = child.previousSibling;
			var next = child.nextSibling;
			if (previous) {
				previous.nextSibling = next;
			} else {
				parentNode.firstChild = next
			}
			if (next) {
				next.previousSibling = previous;
			} else {
				parentNode.lastChild = previous;
			}
			_onUpdateChild(parentNode.ownerDocument, parentNode);
			return child;
		}
		/**
		 * preformance key(refChild == null)
		 */
		function _insertBefore(parentNode, newChild, nextChild) {
			var cp = newChild.parentNode;
			if (cp) {
				cp.removeChild(newChild);//remove and update
			}
			if (newChild.nodeType === DOCUMENT_FRAGMENT_NODE) {
				var newFirst = newChild.firstChild;
				if (newFirst == null) {
					return newChild;
				}
				var newLast = newChild.lastChild;
			} else {
				newFirst = newLast = newChild;
			}
			var pre = nextChild ? nextChild.previousSibling : parentNode.lastChild;

			newFirst.previousSibling = pre;
			newLast.nextSibling = nextChild;


			if (pre) {
				pre.nextSibling = newFirst;
			} else {
				parentNode.firstChild = newFirst;
			}
			if (nextChild == null) {
				parentNode.lastChild = newLast;
			} else {
				nextChild.previousSibling = newLast;
			}
			do {
				newFirst.parentNode = parentNode;
			} while (newFirst !== newLast && (newFirst = newFirst.nextSibling))
			_onUpdateChild(parentNode.ownerDocument || parentNode, parentNode);
			//console.log(parentNode.lastChild.nextSibling == null)
			if (newChild.nodeType == DOCUMENT_FRAGMENT_NODE) {
				newChild.firstChild = newChild.lastChild = null;
			}
			return newChild;
		}
		function _appendSingleChild(parentNode, newChild) {
			var cp = newChild.parentNode;
			if (cp) {
				var pre = parentNode.lastChild;
				cp.removeChild(newChild);//remove and update
				var pre = parentNode.lastChild;
			}
			var pre = parentNode.lastChild;
			newChild.parentNode = parentNode;
			newChild.previousSibling = pre;
			newChild.nextSibling = null;
			if (pre) {
				pre.nextSibling = newChild;
			} else {
				parentNode.firstChild = newChild;
			}
			parentNode.lastChild = newChild;
			_onUpdateChild(parentNode.ownerDocument, parentNode, newChild);
			return newChild;
			//console.log("__aa",parentNode.lastChild.nextSibling == null)
		}
		Document.prototype = {
			//implementation : null,
			nodeName: '#document',
			nodeType: DOCUMENT_NODE,
			doctype: null,
			documentElement: null,
			_inc: 1,

			insertBefore: function (newChild, refChild) {//raises 
				if (newChild.nodeType == DOCUMENT_FRAGMENT_NODE) {
					var child = newChild.firstChild;
					while (child) {
						var next = child.nextSibling;
						this.insertBefore(child, refChild);
						child = next;
					}
					return newChild;
				}
				if (this.documentElement == null && newChild.nodeType == 1) {
					this.documentElement = newChild;
				}

				return _insertBefore(this, newChild, refChild), (newChild.ownerDocument = this), newChild;
			},
			removeChild: function (oldChild) {
				if (this.documentElement == oldChild) {
					this.documentElement = null;
				}
				return _removeChild(this, oldChild);
			},
			// Introduced in DOM Level 2:
			importNode: function (importedNode, deep) {
				return importNode(this, importedNode, deep);
			},
			// Introduced in DOM Level 2:
			getElementById: function (id) {
				var rtv = null;
				_visitNode(this.documentElement, function (node) {
					if (node.nodeType == 1) {
						if (node.getAttribute('id') == id) {
							rtv = node;
							return true;
						}
					}
				})
				return rtv;
			},

			//document factory method:
			createElement: function (tagName) {
				var node = new Element();
				node.ownerDocument = this;
				node.nodeName = tagName;
				node.tagName = tagName;
				node.childNodes = new NodeList();
				var attrs = node.attributes = new NamedNodeMap();
				attrs._ownerElement = node;
				return node;
			},
			createDocumentFragment: function () {
				var node = new DocumentFragment();
				node.ownerDocument = this;
				node.childNodes = new NodeList();
				return node;
			},
			createTextNode: function (data) {
				var node = new Text();
				node.ownerDocument = this;
				node.appendData(data)
				return node;
			},
			createComment: function (data) {
				var node = new Comment();
				node.ownerDocument = this;
				node.appendData(data)
				return node;
			},
			createCDATASection: function (data) {
				var node = new CDATASection();
				node.ownerDocument = this;
				node.appendData(data)
				return node;
			},
			createProcessingInstruction: function (target, data) {
				var node = new ProcessingInstruction();
				node.ownerDocument = this;
				node.tagName = node.target = target;
				node.nodeValue = node.data = data;
				return node;
			},
			createAttribute: function (name) {
				var node = new Attr();
				node.ownerDocument = this;
				node.name = name;
				node.nodeName = name;
				node.localName = name;
				node.specified = true;
				return node;
			},
			createEntityReference: function (name) {
				var node = new EntityReference();
				node.ownerDocument = this;
				node.nodeName = name;
				return node;
			},
			// Introduced in DOM Level 2:
			createElementNS: function (namespaceURI, qualifiedName) {
				var node = new Element();
				var pl = qualifiedName.split(':');
				var attrs = node.attributes = new NamedNodeMap();
				node.childNodes = new NodeList();
				node.ownerDocument = this;
				node.nodeName = qualifiedName;
				node.tagName = qualifiedName;
				node.namespaceURI = namespaceURI;
				if (pl.length == 2) {
					node.prefix = pl[0];
					node.localName = pl[1];
				} else {
					//el.prefix = null;
					node.localName = qualifiedName;
				}
				attrs._ownerElement = node;
				return node;
			},
			// Introduced in DOM Level 2:
			createAttributeNS: function (namespaceURI, qualifiedName) {
				var node = new Attr();
				var pl = qualifiedName.split(':');
				node.ownerDocument = this;
				node.nodeName = qualifiedName;
				node.name = qualifiedName;
				node.namespaceURI = namespaceURI;
				node.specified = true;
				if (pl.length == 2) {
					node.prefix = pl[0];
					node.localName = pl[1];
				} else {
					//el.prefix = null;
					node.localName = qualifiedName;
				}
				return node;
			}
		};
		_extends(Document, Node);


		function Element() {
			this._nsMap = {};
		};
		Element.prototype = {
			nodeType: ELEMENT_NODE,
			hasAttribute: function (name) {
				return this.getAttributeNode(name) != null;
			},
			getAttribute: function (name) {
				var attr = this.getAttributeNode(name);
				return attr && attr.value || '';
			},
			getAttributeNode: function (name) {
				return this.attributes.getNamedItem(name);
			},
			setAttribute: function (name, value) {
				var attr = this.ownerDocument.createAttribute(name);
				attr.value = attr.nodeValue = "" + value;
				this.setAttributeNode(attr)
			},
			removeAttribute: function (name) {
				var attr = this.getAttributeNode(name)
				attr && this.removeAttributeNode(attr);
			},

			//four real opeartion method
			appendChild: function (newChild) {
				if (newChild.nodeType === DOCUMENT_FRAGMENT_NODE) {
					return this.insertBefore(newChild, null);
				} else {
					return _appendSingleChild(this, newChild);
				}
			},
			setAttributeNode: function (newAttr) {
				return this.attributes.setNamedItem(newAttr);
			},
			setAttributeNodeNS: function (newAttr) {
				return this.attributes.setNamedItemNS(newAttr);
			},
			removeAttributeNode: function (oldAttr) {
				return this.attributes.removeNamedItem(oldAttr.nodeName);
			},
			//get real attribute name,and remove it by removeAttributeNode
			removeAttributeNS: function (namespaceURI, localName) {
				var old = this.getAttributeNodeNS(namespaceURI, localName);
				old && this.removeAttributeNode(old);
			},

			hasAttributeNS: function (namespaceURI, localName) {
				return this.getAttributeNodeNS(namespaceURI, localName) != null;
			},
			getAttributeNS: function (namespaceURI, localName) {
				var attr = this.getAttributeNodeNS(namespaceURI, localName);
				return attr && attr.value || '';
			},
			setAttributeNS: function (namespaceURI, qualifiedName, value) {
				var attr = this.ownerDocument.createAttributeNS(namespaceURI, qualifiedName);
				attr.value = attr.nodeValue = value;
				this.setAttributeNode(attr)
			},
			getAttributeNodeNS: function (namespaceURI, localName) {
				return this.attributes.getNamedItemNS(namespaceURI, localName);
			},

			getElementsByTagName: function (tagName) {
				return new LiveNodeList(this, function (base) {
					var ls = [];
					_visitNode(base, function (node) {
						if (node !== base && node.nodeType == ELEMENT_NODE && (tagName === '*' || node.tagName == tagName)) {
							ls.push(node);
						}
					});
					return ls;
				});
			},
			getElementsByTagNameNS: function (namespaceURI, localName) {
				return new LiveNodeList(this, function (base) {
					var ls = [];
					_visitNode(base, function (node) {
						if (node !== base && node.nodeType === ELEMENT_NODE && node.namespaceURI === namespaceURI && (localName === '*' || node.localName == localName)) {
							ls.push(node);
						}
					});
					return ls;
				});
			}
		};
		Document.prototype.getElementsByTagName = Element.prototype.getElementsByTagName;
		Document.prototype.getElementsByTagNameNS = Element.prototype.getElementsByTagNameNS;


		_extends(Element, Node);
		function Attr() {
		};
		Attr.prototype.nodeType = ATTRIBUTE_NODE;
		_extends(Attr, Node);


		function CharacterData() {
		};
		CharacterData.prototype = {
			data: '',
			substringData: function (offset, count) {
				return this.data.substring(offset, offset + count);
			},
			appendData: function (text) {
				text = this.data + text;
				this.nodeValue = this.data = text;
				this.length = text.length;
			},
			insertData: function (offset, text) {
				this.replaceData(offset, 0, text);

			},
			appendChild: function (newChild) {
				//if(!(newChild instanceof CharacterData)){
				throw new Error(ExceptionMessage[3])
				//}
				return Node.prototype.appendChild.apply(this, arguments)
			},
			deleteData: function (offset, count) {
				this.replaceData(offset, count, "");
			},
			replaceData: function (offset, count, text) {
				var start = this.data.substring(0, offset);
				var end = this.data.substring(offset + count);
				text = start + text + end;
				this.nodeValue = this.data = text;
				this.length = text.length;
			}
		}
		_extends(CharacterData, Node);
		function Text() {
		};
		Text.prototype = {
			nodeName: "#text",
			nodeType: TEXT_NODE,
			splitText: function (offset) {
				var text = this.data;
				var newText = text.substring(offset);
				text = text.substring(0, offset);
				this.data = this.nodeValue = text;
				this.length = text.length;
				var newNode = this.ownerDocument.createTextNode(newText);
				if (this.parentNode) {
					this.parentNode.insertBefore(newNode, this.nextSibling);
				}
				return newNode;
			}
		}
		_extends(Text, CharacterData);
		function Comment() {
		};
		Comment.prototype = {
			nodeName: "#comment",
			nodeType: COMMENT_NODE
		}
		_extends(Comment, CharacterData);

		function CDATASection() {
		};
		CDATASection.prototype = {
			nodeName: "#cdata-section",
			nodeType: CDATA_SECTION_NODE
		}
		_extends(CDATASection, CharacterData);


		function DocumentType() {
		};
		DocumentType.prototype.nodeType = DOCUMENT_TYPE_NODE;
		_extends(DocumentType, Node);

		function Notation() {
		};
		Notation.prototype.nodeType = NOTATION_NODE;
		_extends(Notation, Node);

		function Entity() {
		};
		Entity.prototype.nodeType = ENTITY_NODE;
		_extends(Entity, Node);

		function EntityReference() {
		};
		EntityReference.prototype.nodeType = ENTITY_REFERENCE_NODE;
		_extends(EntityReference, Node);

		function DocumentFragment() {
		};
		DocumentFragment.prototype.nodeName = "#document-fragment";
		DocumentFragment.prototype.nodeType = DOCUMENT_FRAGMENT_NODE;
		_extends(DocumentFragment, Node);


		function ProcessingInstruction() {
		}
		ProcessingInstruction.prototype.nodeType = PROCESSING_INSTRUCTION_NODE;
		_extends(ProcessingInstruction, Node);
		function XMLSerializer() { }
		XMLSerializer.prototype.serializeToString = function (node) {
			var buf = [];
			serializeToString(node, buf);
			return buf.join('');
		}
		Node.prototype.toString = function () {
			return XMLSerializer.prototype.serializeToString(this);
		}
		function serializeToString(node, buf) {
			switch (node.nodeType) {
				case ELEMENT_NODE:
					var attrs = node.attributes;
					var len = attrs.length;
					var child = node.firstChild;
					var nodeName = node.tagName;
					var isHTML = htmlns === node.namespaceURI
					buf.push('<', nodeName);
					for (var i = 0; i < len; i++) {
						serializeToString(attrs.item(i), buf, isHTML);
					}
					if (child || isHTML && !/^(?:meta|link|img|br|hr|input)$/i.test(nodeName)) {
						buf.push('>');
						//if is cdata child node
						if (isHTML && /^script$/i.test(nodeName)) {
							if (child) {
								buf.push(child.data);
							}
						} else {
							while (child) {
								serializeToString(child, buf);
								child = child.nextSibling;
							}
						}
						buf.push('</', nodeName, '>');
					} else {
						buf.push('/>');
					}
					return;
				case DOCUMENT_NODE:
				case DOCUMENT_FRAGMENT_NODE:
					var child = node.firstChild;
					while (child) {
						serializeToString(child, buf);
						child = child.nextSibling;
					}
					return;
				case ATTRIBUTE_NODE:
					return buf.push(' ', node.name, '="', node.value.replace(/[<&"]/g, _xmlEncoder), '"');
				case TEXT_NODE:
					return buf.push(node.data.replace(/[<&]/g, _xmlEncoder));
				case CDATA_SECTION_NODE:
					return buf.push('<![CDATA[', node.data, ']]>');
				case COMMENT_NODE:
					return buf.push("<!--", node.data, "-->");
				case DOCUMENT_TYPE_NODE:
					var pubid = node.publicId;
					var sysid = node.systemId;
					buf.push('<!DOCTYPE ', node.name);
					if (pubid) {
						buf.push(' PUBLIC "', pubid);
						if (sysid && sysid != '.') {
							buf.push('" "', sysid);
						}
						buf.push('">');
					} else if (sysid && sysid != '.') {
						buf.push(' SYSTEM "', sysid, '">');
					} else {
						var sub = node.internalSubset;
						if (sub) {
							buf.push(" [", sub, "]");
						}
						buf.push(">");
					}
					return;
				case PROCESSING_INSTRUCTION_NODE:
					return buf.push("<?", node.target, " ", node.data, "?>");
				case ENTITY_REFERENCE_NODE:
					return buf.push('&', node.nodeName, ';');
				//case ENTITY_NODE:
				//case NOTATION_NODE:
				default:
					buf.push('??', node.nodeName);
			}
		}
		function importNode(doc, node, deep) {
			var node2;
			switch (node.nodeType) {
				case ELEMENT_NODE:
					node2 = node.cloneNode(false);
					node2.ownerDocument = doc;
					var attrs = node2.attributes;
					var len = attrs.length;
					for (var i = 0; i < len; i++) {
						node2.setAttributeNodeNS(importNode(doc, attrs.item(i), deep));
					}
				case DOCUMENT_FRAGMENT_NODE:
					break;
				case ATTRIBUTE_NODE:
					deep = true;
					break;
				//case ENTITY_REFERENCE_NODE:
				//case PROCESSING_INSTRUCTION_NODE:
				////case TEXT_NODE:
				//case CDATA_SECTION_NODE:
				//case COMMENT_NODE:
				//	deep = false;
				//	break;
				//case DOCUMENT_NODE:
				//case DOCUMENT_TYPE_NODE:
				//cannot be imported.
				//case ENTITY_NODE:
				//case NOTATION_NODE：
				//can not hit in level3
				//default:throw e;
			}
			if (!node2) {
				node2 = node.cloneNode(false);//false
			}
			node2.ownerDocument = doc;
			node2.parentNode = null;
			if (deep) {
				var child = node.firstChild;
				while (child) {
					node2.appendChild(importNode(doc, child, deep));
					child = child.nextSibling;
				}
			}
			return node2;
		}
		//
		//var _relationMap = {firstChild:1,lastChild:1,previousSibling:1,nextSibling:1,
		//					attributes:1,childNodes:1,parentNode:1,documentElement:1,doctype,};
		function cloneNode(doc, node, deep) {
			var node2 = new node.constructor();
			for (var n in node) {
				var v = node[n];
				if (typeof v != 'object') {
					if (v != node2[n]) {
						node2[n] = v;
					}
				}
			}
			if (node.childNodes) {
				node2.childNodes = new NodeList();
			}
			node2.ownerDocument = doc;
			switch (node2.nodeType) {
				case ELEMENT_NODE:
					var attrs = node.attributes;
					var attrs2 = node2.attributes = new NamedNodeMap();
					var len = attrs.length
					attrs2._ownerElement = node2;
					for (var i = 0; i < len; i++) {
						node2.setAttributeNode(cloneNode(doc, attrs.item(i), true));
					}
					break;;
				case ATTRIBUTE_NODE:
					deep = true;
			}
			if (deep) {
				var child = node.firstChild;
				while (child) {
					node2.appendChild(cloneNode(doc, child, deep));
					child = child.nextSibling;
				}
			}
			return node2;
		}

		function __set__(object, key, value) {
			object[key] = value
		}
		//do dynamic
		try {
			if (Object.defineProperty) {
				Object.defineProperty(LiveNodeList.prototype, 'length', {
					get: function () {
						_updateLiveList(this);
						return this.$$length;
					}
				});
				Object.defineProperty(Node.prototype, 'textContent', {
					get: function () {
						return getTextContent(this);
					},
					set: function (data) {
						switch (this.nodeType) {
							case 1:
							case 11:
								while (this.firstChild) {
									this.removeChild(this.firstChild);
								}
								if (data || String(data)) {
									this.appendChild(this.ownerDocument.createTextNode(data));
								}
								break;
							default:
								//TODO:
								this.data = data;
								this.value = value;
								this.nodeValue = data;
						}
					}
				})

				function getTextContent(node) {
					switch (node.nodeType) {
						case 1:
						case 11:
							var buf = [];
							node = node.firstChild;
							while (node) {
								if (node.nodeType !== 7 && node.nodeType !== 8) {
									buf.push(getTextContent(node));
								}
								node = node.nextSibling;
							}
							return buf.join('');
						default:
							return node.nodeValue;
					}
				}
				__set__ = function (object, key, value) {
					//console.log(value)
					object['$$' + key] = value
				}
			}
		} catch (e) {//ie8
		}

		if (typeof require == 'function') {
			exports.DOMImplementation = DOMImplementation;
			exports.XMLSerializer = XMLSerializer;
		}

	}, {}], 7: [function (require, module, exports) {
		//[4]   	NameStartChar	   ::=   	":" | [A-Z] | "_" | [a-z] | [#xC0-#xD6] | [#xD8-#xF6] | [#xF8-#x2FF] | [#x370-#x37D] | [#x37F-#x1FFF] | [#x200C-#x200D] | [#x2070-#x218F] | [#x2C00-#x2FEF] | [#x3001-#xD7FF] | [#xF900-#xFDCF] | [#xFDF0-#xFFFD] | [#x10000-#xEFFFF]
		//[4a]   	NameChar	   ::=   	NameStartChar | "-" | "." | [0-9] | #xB7 | [#x0300-#x036F] | [#x203F-#x2040]
		//[5]   	Name	   ::=   	NameStartChar (NameChar)*
		var nameStartChar = /[A-Z_a-z\xC0-\xD6\xD8-\xF6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]///\u10000-\uEFFFF
		var nameChar = new RegExp("[\\-\\.0-9" + nameStartChar.source.slice(1, -1) + "\u00B7\u0300-\u036F\\ux203F-\u2040]");
		var tagNamePattern = new RegExp('^' + nameStartChar.source + nameChar.source + '*(?:\:' + nameStartChar.source + nameChar.source + '*)?$');
		//var tagNamePattern = /^[a-zA-Z_][\w\-\.]*(?:\:[a-zA-Z_][\w\-\.]*)?$/
		//var handlers = 'resolveEntity,getExternalSubset,characters,endDocument,endElement,endPrefixMapping,ignorableWhitespace,processingInstruction,setDocumentLocator,skippedEntity,startDocument,startElement,startPrefixMapping,notationDecl,unparsedEntityDecl,error,fatalError,warning,attributeDecl,elementDecl,externalEntityDecl,internalEntityDecl,comment,endCDATA,endDTD,endEntity,startCDATA,startDTD,startEntity'.split(',')

		//S_TAG,	S_ATTR,	S_EQ,	S_V
		//S_ATTR_S,	S_E,	S_S,	S_C
		var S_TAG = 0;//tag name offerring
		var S_ATTR = 1;//attr name offerring 
		var S_ATTR_S = 2;//attr name end and space offer
		var S_EQ = 3;//=space?
		var S_V = 4;//attr value(no quot value only)
		var S_E = 5;//attr value end and no space(quot end)
		var S_S = 6;//(attr value end || tag end ) && (space offer)
		var S_C = 7;//closed el<el />

		function XMLReader() {
		}

		XMLReader.prototype = {
			parse: function (source, defaultNSMap, entityMap) {
				var domBuilder = this.domBuilder;
				domBuilder.startDocument();
				_copy(defaultNSMap, defaultNSMap = {})
				parse(source, defaultNSMap, entityMap,
					domBuilder, this.errorHandler);
				domBuilder.endDocument();
			}
		}
		function parse(source, defaultNSMapCopy, entityMap, domBuilder, errorHandler) {
			function fixedFromCharCode(code) {
				// String.prototype.fromCharCode does not supports
				// > 2 bytes unicode chars directly
				if (code > 0xffff) {
					code -= 0x10000;
					var surrogate1 = 0xd800 + (code >> 10)
						, surrogate2 = 0xdc00 + (code & 0x3ff);

					return String.fromCharCode(surrogate1, surrogate2);
				} else {
					return String.fromCharCode(code);
				}
			}
			function entityReplacer(a) {
				var k = a.slice(1, -1);
				if (k in entityMap) {
					return entityMap[k];
				} else if (k.charAt(0) === '#') {
					return fixedFromCharCode(parseInt(k.substr(1).replace('x', '0x')))
				} else {
					errorHandler.error('entity not found:' + a);
					return a;
				}
			}
			function appendText(end) {//has some bugs
				var xt = source.substring(start, end).replace(/&#?\w+;/g, entityReplacer);
				locator && position(start);
				domBuilder.characters(xt, 0, end - start);
				start = end
			}
			function position(start, m) {
				while (start >= endPos && (m = linePattern.exec(source))) {
					startPos = m.index;
					endPos = startPos + m[0].length;
					locator.lineNumber++;
					//console.log('line++:',locator,startPos,endPos)
				}
				locator.columnNumber = start - startPos + 1;
			}
			var startPos = 0;
			var endPos = 0;
			var linePattern = /.+(?:\r\n?|\n)|.*$/g
			var locator = domBuilder.locator;

			var parseStack = [{ currentNSMap: defaultNSMapCopy }]
			var closeMap = {};
			var start = 0;
			while (true) {
				var i = source.indexOf('<', start);
				if (i > start) {
					appendText(i);
				}
				switch (source.charAt(i + 1)) {
					case '/':
						var end = source.indexOf('>', i + 3);
						var tagName = source.substring(i + 2, end);
						var config = parseStack.pop();
						var localNSMap = config.localNSMap;

						if (config.tagName != tagName) {
							errorHandler.fatalError("end tag name: " + tagName + ' is not match the current start tagName:' + config.tagName);
						}
						domBuilder.endElement(config.uri, config.localName, tagName);
						if (localNSMap) {
							for (var prefix in localNSMap) {
								domBuilder.endPrefixMapping(prefix);
							}
						}
						end++;
						break;
					// end elment
					case '?':// <?...?>
						locator && position(i);
						end = parseInstruction(source, i, domBuilder);
						break;
					case '!':// <!doctype,<![CDATA,<!--
						locator && position(i);
						end = parseDCC(source, i, domBuilder);
						break;
					default:
						if (i < 0) {
							if (!source.substr(start).match(/^\s*$/)) {
								errorHandler.error('source code out of document root');
							}
							return;
						} else {
							try {
								locator && position(i);
								var el = new ElementAttributes();
								//elStartEnd
								var end = parseElementStartPart(source, i, el, entityReplacer, errorHandler);
								var len = el.length;
								//position fixed
								if (len && locator) {
									var backup = copyLocator(locator, {});
									for (var i = 0; i < len; i++) {
										var a = el[i];
										position(a.offset);
										a.offset = copyLocator(locator, {});
									}
									copyLocator(backup, locator);
								}
								el.closed = el.closed || fixSelfClosed(source, end, el.tagName, closeMap);
								appendElement(el, domBuilder, parseStack);


								if (el.uri === 'http://www.w3.org/1999/xhtml' && !el.closed) {
									end = parseHtmlSpecialContent(source, end, el.tagName, entityReplacer, domBuilder)
								} else {
									end++;
								}
							} catch (e) {
								errorHandler.error('element parse error: ' + e);
								end = -1;
							}
						}

				}
				if (end < 0) {
					//TODO: 这里有可能sax回退，有位置错误风险
					appendText(i + 1);
				} else {
					start = end;
				}
			}
		}
		function copyLocator(f, t) {
			t.lineNumber = f.lineNumber;
			t.columnNumber = f.columnNumber;
			return t;

		}

		/**
		 * @see #appendElement(source,elStartEnd,el,selfClosed,entityReplacer,domBuilder,parseStack);
		 * @return end of the elementStartPart(end of elementEndPart for selfClosed el)
		 */
		function parseElementStartPart(source, start, el, entityReplacer, errorHandler) {
			var attrName;
			var value;
			var p = ++start;
			var s = S_TAG;//status
			while (true) {
				var c = source.charAt(p);
				switch (c) {
					case '=':
						if (s === S_ATTR) {//attrName
							attrName = source.slice(start, p);
							s = S_EQ;
						} else if (s === S_ATTR_S) {
							s = S_EQ;
						} else {
							//fatalError: equal must after attrName or space after attrName
							throw new Error('attribute equal must after attrName');
						}
						break;
					case '\'':
					case '"':
						if (s === S_EQ) {//equal
							start = p + 1;
							p = source.indexOf(c, start)
							if (p > 0) {
								value = source.slice(start, p).replace(/&#?\w+;/g, entityReplacer);
								el.add(attrName, value, start - 1);
								s = S_E;
							} else {
								//fatalError: no end quot match
								throw new Error('attribute value no end \'' + c + '\' match');
							}
						} else if (s == S_V) {
							value = source.slice(start, p).replace(/&#?\w+;/g, entityReplacer);
							//console.log(attrName,value,start,p)
							el.add(attrName, value, start);
							//console.dir(el)
							errorHandler.warning('attribute "' + attrName + '" missed start quot(' + c + ')!!');
							start = p + 1;
							s = S_E
						} else {
							//fatalError: no equal before
							throw new Error('attribute value must after "="');
						}
						break;
					case '/':
						switch (s) {
							case S_TAG:
								el.setTagName(source.slice(start, p));
							case S_E:
							case S_S:
							case S_C:
								s = S_C;
								el.closed = true;
							case S_V:
							case S_ATTR:
							case S_ATTR_S:
								break;
							//case S_EQ:
							default:
								throw new Error("attribute invalid close char('/')")
						}
						break;
					case '>':
						switch (s) {
							case S_TAG:
								el.setTagName(source.slice(start, p));
							case S_E:
							case S_S:
							case S_C:
								break;//normal
							case S_V://Compatible state
							case S_ATTR:
								value = source.slice(start, p);
								if (value.slice(-1) === '/') {
									el.closed = true;
									value = value.slice(0, -1)
								}
							case S_ATTR_S:
								if (s === S_ATTR_S) {
									value = attrName;
								}
								if (s == S_V) {
									errorHandler.warning('attribute "' + value + '" missed quot(")!!');
									el.add(attrName, value.replace(/&#?\w+;/g, entityReplacer), start)
								} else {
									errorHandler.warning('attribute "' + value + '" missed value!! "' + value + '" instead!!')
									el.add(value, value, start)
								}
								break;
							case S_EQ:
								throw new Error('attribute value missed!!');
						}
						//			console.log(tagName,tagNamePattern,tagNamePattern.test(tagName))
						return p;
					/*xml space '\x20' | #x9 | #xD | #xA; */
					case '\u0080':
						c = ' ';
					default:
						if (c <= ' ') {//space
							switch (s) {
								case S_TAG:
									el.setTagName(source.slice(start, p));//tagName
									s = S_S;
									break;
								case S_ATTR:
									attrName = source.slice(start, p)
									s = S_ATTR_S;
									break;
								case S_V:
									var value = source.slice(start, p).replace(/&#?\w+;/g, entityReplacer);
									errorHandler.warning('attribute "' + value + '" missed quot(")!!');
									el.add(attrName, value, start)
								case S_E:
									s = S_S;
									break;
								//case S_S:
								//case S_EQ:
								//case S_ATTR_S:
								//	void();break;
								//case S_C:
								//ignore warning
							}
						} else {//not space
							//S_TAG,	S_ATTR,	S_EQ,	S_V
							//S_ATTR_S,	S_E,	S_S,	S_C
							switch (s) {
								//case S_TAG:void();break;
								//case S_ATTR:void();break;
								//case S_V:void();break;
								case S_ATTR_S:
									errorHandler.warning('attribute "' + attrName + '" missed value!! "' + attrName + '" instead!!')
									el.add(attrName, attrName, start);
									start = p;
									s = S_ATTR;
									break;
								case S_E:
									errorHandler.warning('attribute space is required"' + attrName + '"!!')
								case S_S:
									s = S_ATTR;
									start = p;
									break;
								case S_EQ:
									s = S_V;
									start = p;
									break;
								case S_C:
									throw new Error("elements closed character '/' and '>' must be connected to");
							}
						}
				}
				p++;
			}
		}
		/**
		 * @return end of the elementStartPart(end of elementEndPart for selfClosed el)
		 */
		function appendElement(el, domBuilder, parseStack) {
			var tagName = el.tagName;
			var localNSMap = null;
			var currentNSMap = parseStack[parseStack.length - 1].currentNSMap;
			var i = el.length;
			while (i--) {
				var a = el[i];
				var qName = a.qName;
				var value = a.value;
				var nsp = qName.indexOf(':');
				if (nsp > 0) {
					var prefix = a.prefix = qName.slice(0, nsp);
					var localName = qName.slice(nsp + 1);
					var nsPrefix = prefix === 'xmlns' && localName
				} else {
					localName = qName;
					prefix = null
					nsPrefix = qName === 'xmlns' && ''
				}
				//can not set prefix,because prefix !== ''
				a.localName = localName;
				//prefix == null for no ns prefix attribute 
				if (nsPrefix !== false) {//hack!!
					if (localNSMap == null) {
						localNSMap = {}
						_copy(currentNSMap, currentNSMap = {})
					}
					currentNSMap[nsPrefix] = localNSMap[nsPrefix] = value;
					a.uri = 'http://www.w3.org/2000/xmlns/'
					domBuilder.startPrefixMapping(nsPrefix, value)
				}
			}
			var i = el.length;
			while (i--) {
				a = el[i];
				var prefix = a.prefix;
				if (prefix) {//no prefix attribute has no namespace
					if (prefix === 'xml') {
						a.uri = 'http://www.w3.org/XML/1998/namespace';
					} if (prefix !== 'xmlns') {
						a.uri = currentNSMap[prefix]
					}
				}
			}
			var nsp = tagName.indexOf(':');
			if (nsp > 0) {
				prefix = el.prefix = tagName.slice(0, nsp);
				localName = el.localName = tagName.slice(nsp + 1);
			} else {
				prefix = null;//important!!
				localName = el.localName = tagName;
			}
			//no prefix element has default namespace
			var ns = el.uri = currentNSMap[prefix || ''];
			domBuilder.startElement(ns, localName, tagName, el);
			//endPrefixMapping and startPrefixMapping have not any help for dom builder
			//localNSMap = null
			if (el.closed) {
				domBuilder.endElement(ns, localName, tagName);
				if (localNSMap) {
					for (prefix in localNSMap) {
						domBuilder.endPrefixMapping(prefix)
					}
				}
			} else {
				el.currentNSMap = currentNSMap;
				el.localNSMap = localNSMap;
				parseStack.push(el);
			}
		}
		function parseHtmlSpecialContent(source, elStartEnd, tagName, entityReplacer, domBuilder) {
			if (/^(?:script|textarea)$/i.test(tagName)) {
				var elEndStart = source.indexOf('</' + tagName + '>', elStartEnd);
				var text = source.substring(elStartEnd + 1, elEndStart);
				if (/[&<]/.test(text)) {
					if (/^script$/i.test(tagName)) {
						//if(!/\]\]>/.test(text)){
						//lexHandler.startCDATA();
						domBuilder.characters(text, 0, text.length);
						//lexHandler.endCDATA();
						return elEndStart;
						//}
					}//}else{//text area
					text = text.replace(/&#?\w+;/g, entityReplacer);
					domBuilder.characters(text, 0, text.length);
					return elEndStart;
					//}

				}
			}
			return elStartEnd + 1;
		}
		function fixSelfClosed(source, elStartEnd, tagName, closeMap) {
			//if(tagName in closeMap){
			var pos = closeMap[tagName];
			if (pos == null) {
				//console.log(tagName)
				pos = closeMap[tagName] = source.lastIndexOf('</' + tagName + '>')
			}
			return pos < elStartEnd;
			//} 
		}
		function _copy(source, target) {
			for (var n in source) { target[n] = source[n] }
		}
		function parseDCC(source, start, domBuilder) {//sure start with '<!'
			var next = source.charAt(start + 2)
			switch (next) {
				case '-':
					if (source.charAt(start + 3) === '-') {
						var end = source.indexOf('-->', start + 4);
						//append comment source.substring(4,end)//<!--
						domBuilder.comment(source, start + 4, end - start - 4);
						return end + 3;
					} else {
						//error
						return -1;
					}
				default:
					if (source.substr(start + 3, 6) == 'CDATA[') {
						var end = source.indexOf(']]>', start + 9);
						domBuilder.startCDATA();
						domBuilder.characters(source, start + 9, end - start - 9);
						domBuilder.endCDATA()
						return end + 3;
					}
					//<!DOCTYPE
					//startDTD(java.lang.String name, java.lang.String publicId, java.lang.String systemId) 
					var matchs = split(source, start);
					var len = matchs.length;
					if (len > 1 && /!doctype/i.test(matchs[0][0])) {
						var name = matchs[1][0];
						var pubid = len > 3 && /^public$/i.test(matchs[2][0]) && matchs[3][0]
						var sysid = len > 4 && matchs[4][0];
						var lastMatch = matchs[len - 1]
						domBuilder.startDTD(name, pubid, sysid);
						domBuilder.endDTD();

						return lastMatch.index + lastMatch[0].length
					}
			}
			return -1;
		}



		function parseInstruction(source, start, domBuilder) {
			var end = source.indexOf('?>', start);
			if (end) {
				var match = source.substring(start, end).match(/^<\?(\S*)\s*([\s\S]*?)\s*$/);
				if (match) {
					var len = match[0].length;
					domBuilder.processingInstruction(match[1], match[2]);
					return end + 2;
				} else {//error
					return -1;
				}
			}
			return -1;
		}

		/**
		 * @param source
		 */
		function ElementAttributes(source) {

		}
		ElementAttributes.prototype = {
			setTagName: function (tagName) {
				if (!tagNamePattern.test(tagName)) {
					throw new Error('invalid tagName:' + tagName)
				}
				this.tagName = tagName
			},
			add: function (qName, value, offset) {
				if (!tagNamePattern.test(qName)) {
					throw new Error('invalid attribute:' + qName)
				}
				this[this.length++] = { qName: qName, value: value, offset: offset }
			},
			length: 0,
			getLocalName: function (i) { return this[i].localName },
			getOffset: function (i) { return this[i].offset },
			getQName: function (i) { return this[i].qName },
			getURI: function (i) { return this[i].uri },
			getValue: function (i) { return this[i].value }
			//	,getIndex:function(uri, localName)){
			//		if(localName){
			//			
			//		}else{
			//			var qName = uri
			//		}
			//	},
			//	getValue:function(){return this.getValue(this.getIndex.apply(this,arguments))},
			//	getType:function(uri,localName){}
			//	getType:function(i){},
		}




		function _set_proto_(thiz, parent) {
			thiz.__proto__ = parent;
			return thiz;
		}
		if (!(_set_proto_({}, _set_proto_.prototype) instanceof _set_proto_)) {
			_set_proto_ = function (thiz, parent) {
				function p() { };
				p.prototype = parent;
				p = new p();
				for (parent in thiz) {
					p[parent] = thiz[parent];
				}
				return p;
			}
		}

		function split(source, start) {
			var match;
			var buf = [];
			var reg = /'[^']+'|"[^"]+"|[^\s<>\/=]+=?|(\/?\s*>|<)/g;
			reg.lastIndex = start;
			reg.exec(source);//skip <
			while (match = reg.exec(source)) {
				buf.push(match);
				if (match[1]) return buf;
			}
		}

		if (typeof require == 'function') {
			exports.XMLReader = XMLReader;
		}

		if (typeof require == 'function') {
			exports.XMLReader = XMLReader;
		}

	}, {}], 8: [function (require, module, exports) {
		'use strict';

		module.exports = require('./lib')

	}, { "./lib": 13 }], 9: [function (require, module, exports) {
		'use strict';

		var asap = require('asap/raw');

		function noop() { }

		// States:
		//
		// 0 - pending
		// 1 - fulfilled with _value
		// 2 - rejected with _value
		// 3 - adopted the state of another promise, _value
		//
		// once the state is no longer pending (0) it is immutable

		// All `_` prefixed properties will be reduced to `_{random number}`
		// at build time to obfuscate them and discourage their use.
		// We don't use symbols or Object.defineProperty to fully hide them
		// because the performance isn't good enough.


		// to avoid using try/catch inside critical functions, we
		// extract them to here.
		var LAST_ERROR = null;
		var IS_ERROR = {};
		function getThen(obj) {
			try {
				return obj.then;
			} catch (ex) {
				LAST_ERROR = ex;
				return IS_ERROR;
			}
		}

		function tryCallOne(fn, a) {
			try {
				return fn(a);
			} catch (ex) {
				LAST_ERROR = ex;
				return IS_ERROR;
			}
		}
		function tryCallTwo(fn, a, b) {
			try {
				fn(a, b);
			} catch (ex) {
				LAST_ERROR = ex;
				return IS_ERROR;
			}
		}

		module.exports = Promise;

		function Promise(fn) {
			if (typeof this !== 'object') {
				throw new TypeError('Promises must be constructed via new');
			}
			if (typeof fn !== 'function') {
				throw new TypeError('not a function');
			}
			this._45 = 0;
			this._81 = 0;
			this._65 = null;
			this._54 = null;
			if (fn === noop) return;
			doResolve(fn, this);
		}
		Promise._10 = null;
		Promise._97 = null;
		Promise._61 = noop;

		Promise.prototype.then = function (onFulfilled, onRejected) {
			if (this.constructor !== Promise) {
				return safeThen(this, onFulfilled, onRejected);
			}
			var res = new Promise(noop);
			handle(this, new Handler(onFulfilled, onRejected, res));
			return res;
		};

		function safeThen(self, onFulfilled, onRejected) {
			return new self.constructor(function (resolve, reject) {
				var res = new Promise(noop);
				res.then(resolve, reject);
				handle(self, new Handler(onFulfilled, onRejected, res));
			});
		};
		function handle(self, deferred) {
			while (self._81 === 3) {
				self = self._65;
			}
			if (Promise._10) {
				Promise._10(self);
			}
			if (self._81 === 0) {
				if (self._45 === 0) {
					self._45 = 1;
					self._54 = deferred;
					return;
				}
				if (self._45 === 1) {
					self._45 = 2;
					self._54 = [self._54, deferred];
					return;
				}
				self._54.push(deferred);
				return;
			}
			handleResolved(self, deferred);
		}

		function handleResolved(self, deferred) {
			asap(function () {
				var cb = self._81 === 1 ? deferred.onFulfilled : deferred.onRejected;
				if (cb === null) {
					if (self._81 === 1) {
						resolve(deferred.promise, self._65);
					} else {
						reject(deferred.promise, self._65);
					}
					return;
				}
				var ret = tryCallOne(cb, self._65);
				if (ret === IS_ERROR) {
					reject(deferred.promise, LAST_ERROR);
				} else {
					resolve(deferred.promise, ret);
				}
			});
		}
		function resolve(self, newValue) {
			// Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure
			if (newValue === self) {
				return reject(
					self,
					new TypeError('A promise cannot be resolved with itself.')
				);
			}
			if (
				newValue &&
				(typeof newValue === 'object' || typeof newValue === 'function')
			) {
				var then = getThen(newValue);
				if (then === IS_ERROR) {
					return reject(self, LAST_ERROR);
				}
				if (
					then === self.then &&
					newValue instanceof Promise
				) {
					self._81 = 3;
					self._65 = newValue;
					finale(self);
					return;
				} else if (typeof then === 'function') {
					doResolve(then.bind(newValue), self);
					return;
				}
			}
			self._81 = 1;
			self._65 = newValue;
			finale(self);
		}

		function reject(self, newValue) {
			self._81 = 2;
			self._65 = newValue;
			if (Promise._97) {
				Promise._97(self, newValue);
			}
			finale(self);
		}
		function finale(self) {
			if (self._45 === 1) {
				handle(self, self._54);
				self._54 = null;
			}
			if (self._45 === 2) {
				for (var i = 0; i < self._54.length; i++) {
					handle(self, self._54[i]);
				}
				self._54 = null;
			}
		}

		function Handler(onFulfilled, onRejected, promise) {
			this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;
			this.onRejected = typeof onRejected === 'function' ? onRejected : null;
			this.promise = promise;
		}

		/**
		 * Take a potentially misbehaving resolver function and make sure
		 * onFulfilled and onRejected are only called once.
		 *
		 * Makes no guarantees about asynchrony.
		 */
		function doResolve(fn, promise) {
			var done = false;
			var res = tryCallTwo(fn, function (value) {
				if (done) return;
				done = true;
				resolve(promise, value);
			}, function (reason) {
				if (done) return;
				done = true;
				reject(promise, reason);
			})
			if (!done && res === IS_ERROR) {
				done = true;
				reject(promise, LAST_ERROR);
			}
		}

	}, { "asap/raw": 17 }], 10: [function (require, module, exports) {
		'use strict';

		var Promise = require('./core.js');

		module.exports = Promise;
		Promise.prototype.done = function (onFulfilled, onRejected) {
			var self = arguments.length ? this.then.apply(this, arguments) : this;
			self.then(null, function (err) {
				setTimeout(function () {
					throw err;
				}, 0);
			});
		};

	}, { "./core.js": 9 }], 11: [function (require, module, exports) {
		'use strict';

		//This file contains the ES6 extensions to the core Promises/A+ API

		var Promise = require('./core.js');

		module.exports = Promise;

		/* Static Functions */

		var TRUE = valuePromise(true);
		var FALSE = valuePromise(false);
		var NULL = valuePromise(null);
		var UNDEFINED = valuePromise(undefined);
		var ZERO = valuePromise(0);
		var EMPTYSTRING = valuePromise('');

		function valuePromise(value) {
			var p = new Promise(Promise._61);
			p._81 = 1;
			p._65 = value;
			return p;
		}
		Promise.resolve = function (value) {
			if (value instanceof Promise) return value;

			if (value === null) return NULL;
			if (value === undefined) return UNDEFINED;
			if (value === true) return TRUE;
			if (value === false) return FALSE;
			if (value === 0) return ZERO;
			if (value === '') return EMPTYSTRING;

			if (typeof value === 'object' || typeof value === 'function') {
				try {
					var then = value.then;
					if (typeof then === 'function') {
						return new Promise(then.bind(value));
					}
				} catch (ex) {
					return new Promise(function (resolve, reject) {
						reject(ex);
					});
				}
			}
			return valuePromise(value);
		};

		Promise.all = function (arr) {
			var args = Array.prototype.slice.call(arr);

			return new Promise(function (resolve, reject) {
				if (args.length === 0) return resolve([]);
				var remaining = args.length;
				function res(i, val) {
					if (val && (typeof val === 'object' || typeof val === 'function')) {
						if (val instanceof Promise && val.then === Promise.prototype.then) {
							while (val._81 === 3) {
								val = val._65;
							}
							if (val._81 === 1) return res(i, val._65);
							if (val._81 === 2) reject(val._65);
							val.then(function (val) {
								res(i, val);
							}, reject);
							return;
						} else {
							var then = val.then;
							if (typeof then === 'function') {
								var p = new Promise(then.bind(val));
								p.then(function (val) {
									res(i, val);
								}, reject);
								return;
							}
						}
					}
					args[i] = val;
					if (--remaining === 0) {
						resolve(args);
					}
				}
				for (var i = 0; i < args.length; i++) {
					res(i, args[i]);
				}
			});
		};

		Promise.reject = function (value) {
			return new Promise(function (resolve, reject) {
				reject(value);
			});
		};

		Promise.race = function (values) {
			return new Promise(function (resolve, reject) {
				values.forEach(function (value) {
					Promise.resolve(value).then(resolve, reject);
				});
			});
		};

		/* Prototype Methods */

		Promise.prototype['catch'] = function (onRejected) {
			return this.then(null, onRejected);
		};

	}, { "./core.js": 9 }], 12: [function (require, module, exports) {
		'use strict';

		var Promise = require('./core.js');

		module.exports = Promise;
		Promise.prototype['finally'] = function (f) {
			return this.then(function (value) {
				return Promise.resolve(f()).then(function () {
					return value;
				});
			}, function (err) {
				return Promise.resolve(f()).then(function () {
					throw err;
				});
			});
		};

	}, { "./core.js": 9 }], 13: [function (require, module, exports) {
		'use strict';

		module.exports = require('./core.js');
		require('./done.js');
		require('./finally.js');
		require('./es6-extensions.js');
		require('./node-extensions.js');
		require('./synchronous.js');

	}, { "./core.js": 9, "./done.js": 10, "./es6-extensions.js": 11, "./finally.js": 12, "./node-extensions.js": 14, "./synchronous.js": 15 }], 14: [function (require, module, exports) {
		'use strict';

		// This file contains then/promise specific extensions that are only useful
		// for node.js interop

		var Promise = require('./core.js');
		var asap = require('asap');

		module.exports = Promise;

		/* Static Functions */

		Promise.denodeify = function (fn, argumentCount) {
			if (
				typeof argumentCount === 'number' && argumentCount !== Infinity
			) {
				return denodeifyWithCount(fn, argumentCount);
			} else {
				return denodeifyWithoutCount(fn);
			}
		}

		var callbackFn = (
			'function (err, res) {' +
			'if (err) { rj(err); } else { rs(res); }' +
			'}'
		);
		function denodeifyWithCount(fn, argumentCount) {
			var args = [];
			for (var i = 0; i < argumentCount; i++) {
				args.push('a' + i);
			}
			var body = [
				'return function (' + args.join(',') + ') {',
				'var self = this;',
				'return new Promise(function (rs, rj) {',
				'var res = fn.call(',
				['self'].concat(args).concat([callbackFn]).join(','),
				');',
				'if (res &&',
				'(typeof res === "object" || typeof res === "function") &&',
				'typeof res.then === "function"',
				') {rs(res);}',
				'});',
				'};'
			].join('');
			return Function(['Promise', 'fn'], body)(Promise, fn);
		}
		function denodeifyWithoutCount(fn) {
			var fnLength = Math.max(fn.length - 1, 3);
			var args = [];
			for (var i = 0; i < fnLength; i++) {
				args.push('a' + i);
			}
			var body = [
				'return function (' + args.join(',') + ') {',
				'var self = this;',
				'var args;',
				'var argLength = arguments.length;',
				'if (arguments.length > ' + fnLength + ') {',
				'args = new Array(arguments.length + 1);',
				'for (var i = 0; i < arguments.length; i++) {',
				'args[i] = arguments[i];',
				'}',
				'}',
				'return new Promise(function (rs, rj) {',
				'var cb = ' + callbackFn + ';',
				'var res;',
				'switch (argLength) {',
				args.concat(['extra']).map(function (_, index) {
					return (
						'case ' + (index) + ':' +
						'res = fn.call(' + ['self'].concat(args.slice(0, index)).concat('cb').join(',') + ');' +
						'break;'
					);
				}).join(''),
				'default:',
				'args[argLength] = cb;',
				'res = fn.apply(self, args);',
				'}',

				'if (res &&',
				'(typeof res === "object" || typeof res === "function") &&',
				'typeof res.then === "function"',
				') {rs(res);}',
				'});',
				'};'
			].join('');

			return Function(
				['Promise', 'fn'],
				body
			)(Promise, fn);
		}

		Promise.nodeify = function (fn) {
			return function () {
				var args = Array.prototype.slice.call(arguments);
				var callback =
					typeof args[args.length - 1] === 'function' ? args.pop() : null;
				var ctx = this;
				try {
					return fn.apply(this, arguments).nodeify(callback, ctx);
				} catch (ex) {
					if (callback === null || typeof callback == 'undefined') {
						return new Promise(function (resolve, reject) {
							reject(ex);
						});
					} else {
						asap(function () {
							callback.call(ctx, ex);
						})
					}
				}
			}
		}

		Promise.prototype.nodeify = function (callback, ctx) {
			if (typeof callback != 'function') return this;

			this.then(function (value) {
				asap(function () {
					callback.call(ctx, null, value);
				});
			}, function (err) {
				asap(function () {
					callback.call(ctx, err);
				});
			});
		}

	}, { "./core.js": 9, "asap": 16 }], 15: [function (require, module, exports) {
		'use strict';

		var Promise = require('./core.js');

		module.exports = Promise;
		Promise.enableSynchronous = function () {
			Promise.prototype.isPending = function () {
				return this.getState() == 0;
			};

			Promise.prototype.isFulfilled = function () {
				return this.getState() == 1;
			};

			Promise.prototype.isRejected = function () {
				return this.getState() == 2;
			};

			Promise.prototype.getValue = function () {
				if (this._81 === 3) {
					return this._65.getValue();
				}

				if (!this.isFulfilled()) {
					throw new Error('Cannot get a value of an unfulfilled promise.');
				}

				return this._65;
			};

			Promise.prototype.getReason = function () {
				if (this._81 === 3) {
					return this._65.getReason();
				}

				if (!this.isRejected()) {
					throw new Error('Cannot get a rejection reason of a non-rejected promise.');
				}

				return this._65;
			};

			Promise.prototype.getState = function () {
				if (this._81 === 3) {
					return this._65.getState();
				}
				if (this._81 === -1 || this._81 === -2) {
					return 0;
				}

				return this._81;
			};
		};

		Promise.disableSynchronous = function () {
			Promise.prototype.isPending = undefined;
			Promise.prototype.isFulfilled = undefined;
			Promise.prototype.isRejected = undefined;
			Promise.prototype.getValue = undefined;
			Promise.prototype.getReason = undefined;
			Promise.prototype.getState = undefined;
		};

	}, { "./core.js": 9 }], 16: [function (require, module, exports) {
		"use strict";

		// rawAsap provides everything we need except exception management.
		var rawAsap = require("./raw");
		// RawTasks are recycled to reduce GC churn.
		var freeTasks = [];
		// We queue errors to ensure they are thrown in right order (FIFO).
		// Array-as-queue is good enough here, since we are just dealing with exceptions.
		var pendingErrors = [];
		var requestErrorThrow = rawAsap.makeRequestCallFromTimer(throwFirstError);

		function throwFirstError() {
			if (pendingErrors.length) {
				throw pendingErrors.shift();
			}
		}

		/**
		 * Calls a task as soon as possible after returning, in its own event, with priority
		 * over other events like animation, reflow, and repaint. An error thrown from an
		 * event will not interrupt, nor even substantially slow down the processing of
		 * other events, but will be rather postponed to a lower priority event.
		 * @param {{call}} task A callable object, typically a function that takes no
		 * arguments.
		 */
		module.exports = asap;
		function asap(task) {
			var rawTask;
			if (freeTasks.length) {
				rawTask = freeTasks.pop();
			} else {
				rawTask = new RawTask();
			}
			rawTask.task = task;
			rawAsap(rawTask);
		}

		// We wrap tasks with recyclable task objects.  A task object implements
		// `call`, just like a function.
		function RawTask() {
			this.task = null;
		}

		// The sole purpose of wrapping the task is to catch the exception and recycle
		// the task object after its single use.
		RawTask.prototype.call = function () {
			try {
				this.task.call();
			} catch (error) {
				if (asap.onerror) {
					// This hook exists purely for testing purposes.
					// Its name will be periodically randomized to break any code that
					// depends on its existence.
					asap.onerror(error);
				} else {
					// In a web browser, exceptions are not fatal. However, to avoid
					// slowing down the queue of pending tasks, we rethrow the error in a
					// lower priority turn.
					pendingErrors.push(error);
					requestErrorThrow();
				}
			} finally {
				this.task = null;
				freeTasks[freeTasks.length] = this;
			}
		};

	}, { "./raw": 17 }], 17: [function (require, module, exports) {
		(function (global) {
			"use strict";

			// Use the fastest means possible to execute a task in its own turn, with
			// priority over other events including IO, animation, reflow, and redraw
			// events in browsers.
			//
			// An exception thrown by a task will permanently interrupt the processing of
			// subsequent tasks. The higher level `asap` function ensures that if an
			// exception is thrown by a task, that the task queue will continue flushing as
			// soon as possible, but if you use `rawAsap` directly, you are responsible to
			// either ensure that no exceptions are thrown from your task, or to manually
			// call `rawAsap.requestFlush` if an exception is thrown.
			module.exports = rawAsap;
			function rawAsap(task) {
				if (!queue.length) {
					requestFlush();
					flushing = true;
				}
				// Equivalent to push, but avoids a function call.
				queue[queue.length] = task;
			}

			var queue = [];
			// Once a flush has been requested, no further calls to `requestFlush` are
			// necessary until the next `flush` completes.
			var flushing = false;
			// `requestFlush` is an implementation-specific method that attempts to kick
			// off a `flush` event as quickly as possible. `flush` will attempt to exhaust
			// the event queue before yielding to the browser's own event loop.
			var requestFlush;
			// The position of the next task to execute in the task queue. This is
			// preserved between calls to `flush` so that it can be resumed if
			// a task throws an exception.
			var index = 0;
			// If a task schedules additional tasks recursively, the task queue can grow
			// unbounded. To prevent memory exhaustion, the task queue will periodically
			// truncate already-completed tasks.
			var capacity = 1024;

			// The flush function processes all tasks that have been scheduled with
			// `rawAsap` unless and until one of those tasks throws an exception.
			// If a task throws an exception, `flush` ensures that its state will remain
			// consistent and will resume where it left off when called again.
			// However, `flush` does not make any arrangements to be called again if an
			// exception is thrown.
			function flush() {
				while (index < queue.length) {
					var currentIndex = index;
					// Advance the index before calling the task. This ensures that we will
					// begin flushing on the next task the task throws an error.
					index = index + 1;
					queue[currentIndex].call();
					// Prevent leaking memory for long chains of recursive calls to `asap`.
					// If we call `asap` within tasks scheduled by `asap`, the queue will
					// grow, but to avoid an O(n) walk for every task we execute, we don't
					// shift tasks off the queue after they have been executed.
					// Instead, we periodically shift 1024 tasks off the queue.
					if (index > capacity) {
						// Manually shift all values starting at the index back to the
						// beginning of the queue.
						for (var scan = 0, newLength = queue.length - index; scan < newLength; scan++) {
							queue[scan] = queue[scan + index];
						}
						queue.length -= index;
						index = 0;
					}
				}
				queue.length = 0;
				index = 0;
				flushing = false;
			}

			// `requestFlush` is implemented using a strategy based on data collected from
			// every available SauceLabs Selenium web driver worker at time of writing.
			// https://docs.google.com/spreadsheets/d/1mG-5UYGup5qxGdEMWkhP6BWCz053NUb2E1QoUTU16uA/edit#gid=783724593

			// Safari 6 and 6.1 for desktop, iPad, and iPhone are the only browsers that
			// have WebKitMutationObserver but not un-prefixed MutationObserver.
			// Must use `global` or `self` instead of `window` to work in both frames and web
			// workers. `global` is a provision of Browserify, Mr, Mrs, or Mop.

			/* globals self */
			var scope = typeof global !== "undefined" ? global : self;
			var BrowserMutationObserver = scope.MutationObserver || scope.WebKitMutationObserver;

			// MutationObservers are desirable because they have high priority and work
			// reliably everywhere they are implemented.
			// They are implemented in all modern browsers.
			//
			// - Android 4-4.3
			// - Chrome 26-34
			// - Firefox 14-29
			// - Internet Explorer 11
			// - iPad Safari 6-7.1
			// - iPhone Safari 7-7.1
			// - Safari 6-7
			if (typeof BrowserMutationObserver === "function") {
				requestFlush = makeRequestCallFromMutationObserver(flush);

				// MessageChannels are desirable because they give direct access to the HTML
				// task queue, are implemented in Internet Explorer 10, Safari 5.0-1, and Opera
				// 11-12, and in web workers in many engines.
				// Although message channels yield to any queued rendering and IO tasks, they
				// would be better than imposing the 4ms delay of timers.
				// However, they do not work reliably in Internet Explorer or Safari.

				// Internet Explorer 10 is the only browser that has setImmediate but does
				// not have MutationObservers.
				// Although setImmediate yields to the browser's renderer, it would be
				// preferrable to falling back to setTimeout since it does not have
				// the minimum 4ms penalty.
				// Unfortunately there appears to be a bug in Internet Explorer 10 Mobile (and
				// Desktop to a lesser extent) that renders both setImmediate and
				// MessageChannel useless for the purposes of ASAP.
				// https://github.com/kriskowal/q/issues/396

				// Timers are implemented universally.
				// We fall back to timers in workers in most engines, and in foreground
				// contexts in the following browsers.
				// However, note that even this simple case requires nuances to operate in a
				// broad spectrum of browsers.
				//
				// - Firefox 3-13
				// - Internet Explorer 6-9
				// - iPad Safari 4.3
				// - Lynx 2.8.7
			} else {
				requestFlush = makeRequestCallFromTimer(flush);
			}

			// `requestFlush` requests that the high priority event queue be flushed as
			// soon as possible.
			// This is useful to prevent an error thrown in a task from stalling the event
			// queue if the exception handled by Node.js’s
			// `process.on("uncaughtException")` or by a domain.
			rawAsap.requestFlush = requestFlush;

			// To request a high priority event, we induce a mutation observer by toggling
			// the text of a text node between "1" and "-1".
			function makeRequestCallFromMutationObserver(callback) {
				var toggle = 1;
				var observer = new BrowserMutationObserver(callback);
				var node = document.createTextNode("");
				observer.observe(node, { characterData: true });
				return function requestCall() {
					toggle = -toggle;
					node.data = toggle;
				};
			}

			// The message channel technique was discovered by Malte Ubl and was the
			// original foundation for this library.
			// http://www.nonblocking.io/2011/06/windownexttick.html

			// Safari 6.0.5 (at least) intermittently fails to create message ports on a
			// page's first load. Thankfully, this version of Safari supports
			// MutationObservers, so we don't need to fall back in that case.

			// function makeRequestCallFromMessageChannel(callback) {
			//     var channel = new MessageChannel();
			//     channel.port1.onmessage = callback;
			//     return function requestCall() {
			//         channel.port2.postMessage(0);
			//     };
			// }

			// For reasons explained above, we are also unable to use `setImmediate`
			// under any circumstances.
			// Even if we were, there is another bug in Internet Explorer 10.
			// It is not sufficient to assign `setImmediate` to `requestFlush` because
			// `setImmediate` must be called *by name* and therefore must be wrapped in a
			// closure.
			// Never forget.

			// function makeRequestCallFromSetImmediate(callback) {
			//     return function requestCall() {
			//         setImmediate(callback);
			//     };
			// }

			// Safari 6.0 has a problem where timers will get lost while the user is
			// scrolling. This problem does not impact ASAP because Safari 6.0 supports
			// mutation observers, so that implementation is used instead.
			// However, if we ever elect to use timers in Safari, the prevalent work-around
			// is to add a scroll event listener that calls for a flush.

			// `setTimeout` does not call the passed callback if the delay is less than
			// approximately 7 in web workers in Firefox 8 through 18, and sometimes not
			// even then.

			function makeRequestCallFromTimer(callback) {
				return function requestCall() {
					// We dispatch a timeout with a specified delay of 0 for engines that
					// can reliably accommodate that request. This will usually be snapped
					// to a 4 milisecond delay, but once we're flushing, there's no delay
					// between events.
					var timeoutHandle = setTimeout(handleTimer, 0);
					// However, since this timer gets frequently dropped in Firefox
					// workers, we enlist an interval handle that will try to fire
					// an event 20 times per second until it succeeds.
					var intervalHandle = setInterval(handleTimer, 50);

					function handleTimer() {
						// Whichever timer succeeds will cancel both timers and
						// execute the callback.
						clearTimeout(timeoutHandle);
						clearInterval(intervalHandle);
						callback();
					}
				};
			}

			// This is for `asap.js` only.
			// Its name will be periodically randomized to break any code that depends on
			// its existence.
			rawAsap.makeRequestCallFromTimer = makeRequestCallFromTimer;

			// ASAP was originally a nextTick shim included in Q. This was factored out
			// into this ASAP package. It was later adapted to RSVP which made further
			// amendments. These decisions, particularly to marginalize MessageChannel and
			// to capture the MutationObserver implementation in a closure, were integrated
			// back into ASAP proper.
			// https://github.com/tildeio/rsvp.js/blob/cddf7232546a9cf858524b75cde6f9edf72620a7/lib/rsvp/asap.js

		}).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
	}, {}], 18: [function (require, module, exports) {
		/**
		 * Module dependencies.
		 */

		var Emitter = require('emitter');
		var reduce = require('reduce');
		var requestBase = require('./request-base');
		var isObject = require('./is-object');

		/**
		 * Root reference for iframes.
		 */

		var root;
		if (typeof window !== 'undefined') { // Browser window
			root = window;
		} else if (typeof self !== 'undefined') { // Web Worker
			root = self;
		} else { // Other environments
			root = this;
		}

		/**
		 * Noop.
		 */

		function noop() { };

		/**
		 * Check if `obj` is a host object,
		 * we don't want to serialize these :)
		 *
		 * TODO: future proof, move to compoent land
		 *
		 * @param {Object} obj
		 * @return {Boolean}
		 * @api private
		 */

		function isHost(obj) {
			var str = {}.toString.call(obj);

			switch (str) {
				case '[object File]':
				case '[object Blob]':
				case '[object FormData]':
					return true;
				default:
					return false;
			}
		}

		/**
		 * Expose `request`.
		 */

		var request = module.exports = require('./request').bind(null, Request);

		/**
		 * Determine XHR.
		 */

		request.getXHR = function () {
			if (root.XMLHttpRequest
				&& (!root.location || 'file:' != root.location.protocol
					|| !root.ActiveXObject)) {
				return new XMLHttpRequest;
			} else {
				try { return new ActiveXObject('Microsoft.XMLHTTP'); } catch (e) { }
				try { return new ActiveXObject('Msxml2.XMLHTTP.6.0'); } catch (e) { }
				try { return new ActiveXObject('Msxml2.XMLHTTP.3.0'); } catch (e) { }
				try { return new ActiveXObject('Msxml2.XMLHTTP'); } catch (e) { }
			}
			return false;
		};

		/**
		 * Removes leading and trailing whitespace, added to support IE.
		 *
		 * @param {String} s
		 * @return {String}
		 * @api private
		 */

		var trim = ''.trim
			? function (s) { return s.trim(); }
			: function (s) { return s.replace(/(^\s*|\s*$)/g, ''); };

		/**
		 * Serialize the given `obj`.
		 *
		 * @param {Object} obj
		 * @return {String}
		 * @api private
		 */

		function serialize(obj) {
			if (!isObject(obj)) return obj;
			var pairs = [];
			for (var key in obj) {
				if (null != obj[key]) {
					pushEncodedKeyValuePair(pairs, key, obj[key]);
				}
			}
			return pairs.join('&');
		}

		/**
		 * Helps 'serialize' with serializing arrays.
		 * Mutates the pairs array.
		 *
		 * @param {Array} pairs
		 * @param {String} key
		 * @param {Mixed} val
		 */

		function pushEncodedKeyValuePair(pairs, key, val) {
			if (Array.isArray(val)) {
				return val.forEach(function (v) {
					pushEncodedKeyValuePair(pairs, key, v);
				});
			}
			pairs.push(encodeURIComponent(key)
				+ '=' + encodeURIComponent(val));
		}

		/**
		 * Expose serialization method.
		 */

		request.serializeObject = serialize;

		/**
		 * Parse the given x-www-form-urlencoded `str`.
		 *
		 * @param {String} str
		 * @return {Object}
		 * @api private
		 */

		function parseString(str) {
			var obj = {};
			var pairs = str.split('&');
			var parts;
			var pair;

			for (var i = 0, len = pairs.length; i < len; ++i) {
				pair = pairs[i];
				parts = pair.split('=');
				obj[decodeURIComponent(parts[0])] = decodeURIComponent(parts[1]);
			}

			return obj;
		}

		/**
		 * Expose parser.
		 */

		request.parseString = parseString;

		/**
		 * Default MIME type map.
		 *
		 *     superagent.types.xml = 'application/xml';
		 *
		 */

		request.types = {
			html: 'text/html',
			json: 'application/json',
			xml: 'application/xml',
			urlencoded: 'application/x-www-form-urlencoded',
			'form': 'application/x-www-form-urlencoded',
			'form-data': 'application/x-www-form-urlencoded'
		};

		/**
		 * Default serialization map.
		 *
		 *     superagent.serialize['application/xml'] = function(obj){
		 *       return 'generated xml here';
		 *     };
		 *
		 */

		request.serialize = {
			'application/x-www-form-urlencoded': serialize,
			'application/json': JSON.stringify
		};

		/**
		 * Default parsers.
		 *
		 *     superagent.parse['application/xml'] = function(str){
		 *       return { object parsed from str };
		 *     };
		 *
		 */

		request.parse = {
			'application/x-www-form-urlencoded': parseString,
			'application/json': JSON.parse
		};

		/**
		 * Parse the given header `str` into
		 * an object containing the mapped fields.
		 *
		 * @param {String} str
		 * @return {Object}
		 * @api private
		 */

		function parseHeader(str) {
			var lines = str.split(/\r?\n/);
			var fields = {};
			var index;
			var line;
			var field;
			var val;

			lines.pop(); // trailing CRLF

			for (var i = 0, len = lines.length; i < len; ++i) {
				line = lines[i];
				index = line.indexOf(':');
				field = line.slice(0, index).toLowerCase();
				val = trim(line.slice(index + 1));
				fields[field] = val;
			}

			return fields;
		}

		/**
		 * Check if `mime` is json or has +json structured syntax suffix.
		 *
		 * @param {String} mime
		 * @return {Boolean}
		 * @api private
		 */

		function isJSON(mime) {
			return /[\/+]json\b/.test(mime);
		}

		/**
		 * Return the mime type for the given `str`.
		 *
		 * @param {String} str
		 * @return {String}
		 * @api private
		 */

		function type(str) {
			return str.split(/ *; */).shift();
		};

		/**
		 * Return header field parameters.
		 *
		 * @param {String} str
		 * @return {Object}
		 * @api private
		 */

		function params(str) {
			return reduce(str.split(/ *; */), function (obj, str) {
				var parts = str.split(/ *= */)
					, key = parts.shift()
					, val = parts.shift();

				if (key && val) obj[key] = val;
				return obj;
			}, {});
		};

		/**
		 * Initialize a new `Response` with the given `xhr`.
		 *
		 *  - set flags (.ok, .error, etc)
		 *  - parse header
		 *
		 * Examples:
		 *
		 *  Aliasing `superagent` as `request` is nice:
		 *
		 *      request = superagent;
		 *
		 *  We can use the promise-like API, or pass callbacks:
		 *
		 *      request.get('/').end(function(res){});
		 *      request.get('/', function(res){});
		 *
		 *  Sending data can be chained:
		 *
		 *      request
		 *        .post('/user')
		 *        .send({ name: 'tj' })
		 *        .end(function(res){});
		 *
		 *  Or passed to `.send()`:
		 *
		 *      request
		 *        .post('/user')
		 *        .send({ name: 'tj' }, function(res){});
		 *
		 *  Or passed to `.post()`:
		 *
		 *      request
		 *        .post('/user', { name: 'tj' })
		 *        .end(function(res){});
		 *
		 * Or further reduced to a single call for simple cases:
		 *
		 *      request
		 *        .post('/user', { name: 'tj' }, function(res){});
		 *
		 * @param {XMLHTTPRequest} xhr
		 * @param {Object} options
		 * @api private
		 */

		function Response(req, options) {
			options = options || {};
			this.req = req;
			this.xhr = this.req.xhr;
			// responseText is accessible only if responseType is '' or 'text' and on older browsers
			this.text = ((this.req.method != 'HEAD' && (this.xhr.responseType === '' || this.xhr.responseType === 'text')) || typeof this.xhr.responseType === 'undefined')
				? this.xhr.responseText
				: null;
			this.statusText = this.req.xhr.statusText;
			this.setStatusProperties(this.xhr.status);
			this.header = this.headers = parseHeader(this.xhr.getAllResponseHeaders());
			// getAllResponseHeaders sometimes falsely returns "" for CORS requests, but
			// getResponseHeader still works. so we get content-type even if getting
			// other headers fails.
			this.header['content-type'] = this.xhr.getResponseHeader('content-type');
			this.setHeaderProperties(this.header);
			this.body = this.req.method != 'HEAD'
				? this.parseBody(this.text ? this.text : this.xhr.response)
				: null;
		}

		/**
		 * Get case-insensitive `field` value.
		 *
		 * @param {String} field
		 * @return {String}
		 * @api public
		 */

		Response.prototype.get = function (field) {
			return this.header[field.toLowerCase()];
		};

		/**
		 * Set header related properties:
		 *
		 *   - `.type` the content type without params
		 *
		 * A response of "Content-Type: text/plain; charset=utf-8"
		 * will provide you with a `.type` of "text/plain".
		 *
		 * @param {Object} header
		 * @api private
		 */

		Response.prototype.setHeaderProperties = function (header) {
			// content-type
			var ct = this.header['content-type'] || '';
			this.type = type(ct);

			// params
			var obj = params(ct);
			for (var key in obj) this[key] = obj[key];
		};

		/**
		 * Parse the given body `str`.
		 *
		 * Used for auto-parsing of bodies. Parsers
		 * are defined on the `superagent.parse` object.
		 *
		 * @param {String} str
		 * @return {Mixed}
		 * @api private
		 */

		Response.prototype.parseBody = function (str) {
			var parse = request.parse[this.type];
			if (!parse && isJSON(this.type)) {
				parse = request.parse['application/json'];
			}
			return parse && str && (str.length || str instanceof Object)
				? parse(str)
				: null;
		};

		/**
		 * Set flags such as `.ok` based on `status`.
		 *
		 * For example a 2xx response will give you a `.ok` of __true__
		 * whereas 5xx will be __false__ and `.error` will be __true__. The
		 * `.clientError` and `.serverError` are also available to be more
		 * specific, and `.statusType` is the class of error ranging from 1..5
		 * sometimes useful for mapping respond colors etc.
		 *
		 * "sugar" properties are also defined for common cases. Currently providing:
		 *
		 *   - .noContent
		 *   - .badRequest
		 *   - .unauthorized
		 *   - .notAcceptable
		 *   - .notFound
		 *
		 * @param {Number} status
		 * @api private
		 */

		Response.prototype.setStatusProperties = function (status) {
			// handle IE9 bug: http://stackoverflow.com/questions/10046972/msie-returns-status-code-of-1223-for-ajax-request
			if (status === 1223) {
				status = 204;
			}

			var type = status / 100 | 0;

			// status / class
			this.status = this.statusCode = status;
			this.statusType = type;

			// basics
			this.info = 1 == type;
			this.ok = 2 == type;
			this.clientError = 4 == type;
			this.serverError = 5 == type;
			this.error = (4 == type || 5 == type)
				? this.toError()
				: false;

			// sugar
			this.accepted = 202 == status;
			this.noContent = 204 == status;
			this.badRequest = 400 == status;
			this.unauthorized = 401 == status;
			this.notAcceptable = 406 == status;
			this.notFound = 404 == status;
			this.forbidden = 403 == status;
		};

		/**
		 * Return an `Error` representative of this response.
		 *
		 * @return {Error}
		 * @api public
		 */

		Response.prototype.toError = function () {
			var req = this.req;
			var method = req.method;
			var url = req.url;

			var msg = 'cannot ' + method + ' ' + url + ' (' + this.status + ')';
			var err = new Error(msg);
			err.status = this.status;
			err.method = method;
			err.url = url;

			return err;
		};

		/**
		 * Expose `Response`.
		 */

		request.Response = Response;

		/**
		 * Initialize a new `Request` with the given `method` and `url`.
		 *
		 * @param {String} method
		 * @param {String} url
		 * @api public
		 */

		function Request(method, url) {
			var self = this;
			this._query = this._query || [];
			this.method = method;
			this.url = url;
			this.header = {}; // preserves header name case
			this._header = {}; // coerces header names to lowercase
			this.on('end', function () {
				var err = null;
				var res = null;

				try {
					res = new Response(self);
				} catch (e) {
					err = new Error('Parser is unable to parse the response');
					err.parse = true;
					err.original = e;
					// issue #675: return the raw response if the response parsing fails
					err.rawResponse = self.xhr && self.xhr.responseText ? self.xhr.responseText : null;
					// issue #876: return the http status code if the response parsing fails
					err.statusCode = self.xhr && self.xhr.status ? self.xhr.status : null;
					return self.callback(err);
				}

				self.emit('response', res);

				if (err) {
					return self.callback(err, res);
				}

				if (res.status >= 200 && res.status < 300) {
					return self.callback(err, res);
				}

				var new_err = new Error(res.statusText || 'Unsuccessful HTTP response');
				new_err.original = err;
				new_err.response = res;
				new_err.status = res.status;

				self.callback(new_err, res);
			});
		}

		/**
		 * Mixin `Emitter` and `requestBase`.
		 */

		Emitter(Request.prototype);
		for (var key in requestBase) {
			Request.prototype[key] = requestBase[key];
		}

		/**
		 * Abort the request, and clear potential timeout.
		 *
		 * @return {Request}
		 * @api public
		 */

		Request.prototype.abort = function () {
			if (this.aborted) return;
			this.aborted = true;
			this.xhr && this.xhr.abort();
			this.clearTimeout();
			this.emit('abort');
			return this;
		};

		/**
		 * Set Content-Type to `type`, mapping values from `request.types`.
		 *
		 * Examples:
		 *
		 *      superagent.types.xml = 'application/xml';
		 *
		 *      request.post('/')
		 *        .type('xml')
		 *        .send(xmlstring)
		 *        .end(callback);
		 *
		 *      request.post('/')
		 *        .type('application/xml')
		 *        .send(xmlstring)
		 *        .end(callback);
		 *
		 * @param {String} type
		 * @return {Request} for chaining
		 * @api public
		 */

		Request.prototype.type = function (type) {
			this.set('Content-Type', request.types[type] || type);
			return this;
		};

		/**
		 * Set responseType to `val`. Presently valid responseTypes are 'blob' and 
		 * 'arraybuffer'.
		 *
		 * Examples:
		 *
		 *      req.get('/')
		 *        .responseType('blob')
		 *        .end(callback);
		 *
		 * @param {String} val
		 * @return {Request} for chaining
		 * @api public
		 */

		Request.prototype.responseType = function (val) {
			this._responseType = val;
			return this;
		};

		/**
		 * Set Accept to `type`, mapping values from `request.types`.
		 *
		 * Examples:
		 *
		 *      superagent.types.json = 'application/json';
		 *
		 *      request.get('/agent')
		 *        .accept('json')
		 *        .end(callback);
		 *
		 *      request.get('/agent')
		 *        .accept('application/json')
		 *        .end(callback);
		 *
		 * @param {String} accept
		 * @return {Request} for chaining
		 * @api public
		 */

		Request.prototype.accept = function (type) {
			this.set('Accept', request.types[type] || type);
			return this;
		};

		/**
		 * Set Authorization field value with `user` and `pass`.
		 *
		 * @param {String} user
		 * @param {String} pass
		 * @param {Object} options with 'type' property 'auto' or 'basic' (default 'basic')
		 * @return {Request} for chaining
		 * @api public
		 */

		Request.prototype.auth = function (user, pass, options) {
			if (!options) {
				options = {
					type: 'basic'
				}
			}

			switch (options.type) {
				case 'basic':
					var str = btoa(user + ':' + pass);
					this.set('Authorization', 'Basic ' + str);
					break;

				case 'auto':
					this.username = user;
					this.password = pass;
					break;
			}
			return this;
		};

		/**
		* Add query-string `val`.
		*
		* Examples:
		*
		*   request.get('/shoes')
		*     .query('size=10')
		*     .query({ color: 'blue' })
		*
		* @param {Object|String} val
		* @return {Request} for chaining
		* @api public
		*/

		Request.prototype.query = function (val) {
			if ('string' != typeof val) val = serialize(val);
			if (val) this._query.push(val);
			return this;
		};

		/**
		 * Queue the given `file` as an attachment to the specified `field`,
		 * with optional `filename`.
		 *
		 * ``` js
		 * request.post('/upload')
		 *   .attach(new Blob(['<a id="a"><b id="b">hey!</b></a>'], { type: "text/html"}))
		 *   .end(callback);
		 * ```
		 *
		 * @param {String} field
		 * @param {Blob|File} file
		 * @param {String} filename
		 * @return {Request} for chaining
		 * @api public
		 */

		Request.prototype.attach = function (field, file, filename) {
			this._getFormData().append(field, file, filename || file.name);
			return this;
		};

		Request.prototype._getFormData = function () {
			if (!this._formData) {
				this._formData = new root.FormData();
			}
			return this._formData;
		};

		/**
		 * Send `data` as the request body, defaulting the `.type()` to "json" when
		 * an object is given.
		 *
		 * Examples:
		 *
		 *       // manual json
		 *       request.post('/user')
		 *         .type('json')
		 *         .send('{"name":"tj"}')
		 *         .end(callback)
		 *
		 *       // auto json
		 *       request.post('/user')
		 *         .send({ name: 'tj' })
		 *         .end(callback)
		 *
		 *       // manual x-www-form-urlencoded
		 *       request.post('/user')
		 *         .type('form')
		 *         .send('name=tj')
		 *         .end(callback)
		 *
		 *       // auto x-www-form-urlencoded
		 *       request.post('/user')
		 *         .type('form')
		 *         .send({ name: 'tj' })
		 *         .end(callback)
		 *
		 *       // defaults to x-www-form-urlencoded
			*      request.post('/user')
			*        .send('name=tobi')
			*        .send('species=ferret')
			*        .end(callback)
		 *
		 * @param {String|Object} data
		 * @return {Request} for chaining
		 * @api public
		 */

		Request.prototype.send = function (data) {
			var obj = isObject(data);
			var type = this._header['content-type'];

			// merge
			if (obj && isObject(this._data)) {
				for (var key in data) {
					this._data[key] = data[key];
				}
			} else if ('string' == typeof data) {
				if (!type) this.type('form');
				type = this._header['content-type'];
				if ('application/x-www-form-urlencoded' == type) {
					this._data = this._data
						? this._data + '&' + data
						: data;
				} else {
					this._data = (this._data || '') + data;
				}
			} else {
				this._data = data;
			}

			if (!obj || isHost(data)) return this;
			if (!type) this.type('json');
			return this;
		};

		/**
		 * @deprecated
		 */
		Response.prototype.parse = function serialize(fn) {
			if (root.console) {
				console.warn("Client-side parse() method has been renamed to serialize(). This method is not compatible with superagent v2.0");
			}
			this.serialize(fn);
			return this;
		};

		Response.prototype.serialize = function serialize(fn) {
			this._parser = fn;
			return this;
		};

		/**
		 * Invoke the callback with `err` and `res`
		 * and handle arity check.
		 *
		 * @param {Error} err
		 * @param {Response} res
		 * @api private
		 */

		Request.prototype.callback = function (err, res) {
			var fn = this._callback;
			this.clearTimeout();
			fn(err, res);
		};

		/**
		 * Invoke callback with x-domain error.
		 *
		 * @api private
		 */

		Request.prototype.crossDomainError = function () {
			var err = new Error('Request has been terminated\nPossible causes: the network is offline, Origin is not allowed by Access-Control-Allow-Origin, the page is being unloaded, etc.');
			err.crossDomain = true;

			err.status = this.status;
			err.method = this.method;
			err.url = this.url;

			this.callback(err);
		};

		/**
		 * Invoke callback with timeout error.
		 *
		 * @api private
		 */

		Request.prototype.timeoutError = function () {
			var timeout = this._timeout;
			var err = new Error('timeout of ' + timeout + 'ms exceeded');
			err.timeout = timeout;
			this.callback(err);
		};

		/**
		 * Enable transmission of cookies with x-domain requests.
		 *
		 * Note that for this to work the origin must not be
		 * using "Access-Control-Allow-Origin" with a wildcard,
		 * and also must set "Access-Control-Allow-Credentials"
		 * to "true".
		 *
		 * @api public
		 */

		Request.prototype.withCredentials = function () {
			this._withCredentials = true;
			return this;
		};

		/**
		 * Initiate request, invoking callback `fn(res)`
		 * with an instanceof `Response`.
		 *
		 * @param {Function} fn
		 * @return {Request} for chaining
		 * @api public
		 */

		Request.prototype.end = function (fn) {
			var self = this;
			var xhr = this.xhr = request.getXHR();
			var query = this._query.join('&');
			var timeout = this._timeout;
			var data = this._formData || this._data;

			// store callback
			this._callback = fn || noop;

			// state change
			xhr.onreadystatechange = function () {
				if (4 != xhr.readyState) return;

				// In IE9, reads to any property (e.g. status) off of an aborted XHR will
				// result in the error "Could not complete the operation due to error c00c023f"
				var status;
				try { status = xhr.status } catch (e) { status = 0; }

				if (0 == status) {
					if (self.timedout) return self.timeoutError();
					if (self.aborted) return;
					return self.crossDomainError();
				}
				self.emit('end');
			};

			// progress
			var handleProgress = function (e) {
				if (e.total > 0) {
					e.percent = e.loaded / e.total * 100;
				}
				e.direction = 'download';
				self.emit('progress', e);
			};
			if (this.hasListeners('progress')) {
				xhr.onprogress = handleProgress;
			}
			try {
				if (xhr.upload && this.hasListeners('progress')) {
					xhr.upload.onprogress = handleProgress;
				}
			} catch (e) {
				// Accessing xhr.upload fails in IE from a web worker, so just pretend it doesn't exist.
				// Reported here:
				// https://connect.microsoft.com/IE/feedback/details/837245/xmlhttprequest-upload-throws-invalid-argument-when-used-from-web-worker-context
			}

			// timeout
			if (timeout && !this._timer) {
				this._timer = setTimeout(function () {
					self.timedout = true;
					self.abort();
				}, timeout);
			}

			// querystring
			if (query) {
				query = request.serializeObject(query);
				this.url += ~this.url.indexOf('?')
					? '&' + query
					: '?' + query;
			}

			// initiate request
			if (this.username && this.password) {
				xhr.open(this.method, this.url, true, this.username, this.password);
			} else {
				xhr.open(this.method, this.url, true);
			}

			// CORS
			if (this._withCredentials) xhr.withCredentials = true;

			// body
			if ('GET' != this.method && 'HEAD' != this.method && 'string' != typeof data && !isHost(data)) {
				// serialize stuff
				var contentType = this._header['content-type'];
				var serialize = this._parser || request.serialize[contentType ? contentType.split(';')[0] : ''];
				if (!serialize && isJSON(contentType)) serialize = request.serialize['application/json'];
				if (serialize) data = serialize(data);
			}

			// set header fields
			for (var field in this.header) {
				if (null == this.header[field]) continue;
				xhr.setRequestHeader(field, this.header[field]);
			}

			if (this._responseType) {
				xhr.responseType = this._responseType;
			}

			// send stuff
			this.emit('request', this);

			// IE11 xhr.send(undefined) sends 'undefined' string as POST payload (instead of nothing)
			// We need null here if data is undefined
			xhr.send(typeof data !== 'undefined' ? data : null);
			return this;
		};


		/**
		 * Expose `Request`.
		 */

		request.Request = Request;

		/**
		 * GET `url` with optional callback `fn(res)`.
		 *
		 * @param {String} url
		 * @param {Mixed|Function} data or fn
		 * @param {Function} fn
		 * @return {Request}
		 * @api public
		 */

		request.get = function (url, data, fn) {
			var req = request('GET', url);
			if ('function' == typeof data) fn = data, data = null;
			if (data) req.query(data);
			if (fn) req.end(fn);
			return req;
		};

		/**
		 * HEAD `url` with optional callback `fn(res)`.
		 *
		 * @param {String} url
		 * @param {Mixed|Function} data or fn
		 * @param {Function} fn
		 * @return {Request}
		 * @api public
		 */

		request.head = function (url, data, fn) {
			var req = request('HEAD', url);
			if ('function' == typeof data) fn = data, data = null;
			if (data) req.send(data);
			if (fn) req.end(fn);
			return req;
		};

		/**
		 * DELETE `url` with optional callback `fn(res)`.
		 *
		 * @param {String} url
		 * @param {Function} fn
		 * @return {Request}
		 * @api public
		 */

		function del(url, fn) {
			var req = request('DELETE', url);
			if (fn) req.end(fn);
			return req;
		};

		request['del'] = del;
		request['delete'] = del;

		/**
		 * PATCH `url` with optional `data` and callback `fn(res)`.
		 *
		 * @param {String} url
		 * @param {Mixed} data
		 * @param {Function} fn
		 * @return {Request}
		 * @api public
		 */

		request.patch = function (url, data, fn) {
			var req = request('PATCH', url);
			if ('function' == typeof data) fn = data, data = null;
			if (data) req.send(data);
			if (fn) req.end(fn);
			return req;
		};

		/**
		 * POST `url` with optional `data` and callback `fn(res)`.
		 *
		 * @param {String} url
		 * @param {Mixed} data
		 * @param {Function} fn
		 * @return {Request}
		 * @api public
		 */

		request.post = function (url, data, fn) {
			var req = request('POST', url);
			if ('function' == typeof data) fn = data, data = null;
			if (data) req.send(data);
			if (fn) req.end(fn);
			return req;
		};

		/**
		 * PUT `url` with optional `data` and callback `fn(res)`.
		 *
		 * @param {String} url
		 * @param {Mixed|Function} data or fn
		 * @param {Function} fn
		 * @return {Request}
		 * @api public
		 */

		request.put = function (url, data, fn) {
			var req = request('PUT', url);
			if ('function' == typeof data) fn = data, data = null;
			if (data) req.send(data);
			if (fn) req.end(fn);
			return req;
		};

	}, { "./is-object": 19, "./request": 21, "./request-base": 20, "emitter": 22, "reduce": 23 }], 19: [function (require, module, exports) {
		/**
		 * Check if `obj` is an object.
		 *
		 * @param {Object} obj
		 * @return {Boolean}
		 * @api private
		 */

		function isObject(obj) {
			return null != obj && 'object' == typeof obj;
		}

		module.exports = isObject;

	}, {}], 20: [function (require, module, exports) {
		/**
		 * Module of mixed-in functions shared between node and client code
		 */
		var isObject = require('./is-object');

		/**
		 * Clear previous timeout.
		 *
		 * @return {Request} for chaining
		 * @api public
		 */

		exports.clearTimeout = function _clearTimeout() {
			this._timeout = 0;
			clearTimeout(this._timer);
			return this;
		};

		/**
		 * Force given parser
		 *
		 * Sets the body parser no matter type.
		 *
		 * @param {Function}
		 * @api public
		 */

		exports.parse = function parse(fn) {
			this._parser = fn;
			return this;
		};

		/**
		 * Set timeout to `ms`.
		 *
		 * @param {Number} ms
		 * @return {Request} for chaining
		 * @api public
		 */

		exports.timeout = function timeout(ms) {
			this._timeout = ms;
			return this;
		};

		/**
		 * Faux promise support
		 *
		 * @param {Function} fulfill
		 * @param {Function} reject
		 * @return {Request}
		 */

		exports.then = function then(fulfill, reject) {
			return this.end(function (err, res) {
				err ? reject(err) : fulfill(res);
			});
		}

		/**
		 * Allow for extension
		 */

		exports.use = function use(fn) {
			fn(this);
			return this;
		}


		/**
		 * Get request header `field`.
		 * Case-insensitive.
		 *
		 * @param {String} field
		 * @return {String}
		 * @api public
		 */

		exports.get = function (field) {
			return this._header[field.toLowerCase()];
		};

		/**
		 * Get case-insensitive header `field` value.
		 * This is a deprecated internal API. Use `.get(field)` instead.
		 *
		 * (getHeader is no longer used internally by the superagent code base)
		 *
		 * @param {String} field
		 * @return {String}
		 * @api private
		 * @deprecated
		 */

		exports.getHeader = exports.get;

		/**
		 * Set header `field` to `val`, or multiple fields with one object.
		 * Case-insensitive.
		 *
		 * Examples:
		 *
		 *      req.get('/')
		 *        .set('Accept', 'application/json')
		 *        .set('X-API-Key', 'foobar')
		 *        .end(callback);
		 *
		 *      req.get('/')
		 *        .set({ Accept: 'application/json', 'X-API-Key': 'foobar' })
		 *        .end(callback);
		 *
		 * @param {String|Object} field
		 * @param {String} val
		 * @return {Request} for chaining
		 * @api public
		 */

		exports.set = function (field, val) {
			if (isObject(field)) {
				for (var key in field) {
					this.set(key, field[key]);
				}
				return this;
			}
			this._header[field.toLowerCase()] = val;
			this.header[field] = val;
			return this;
		};

		/**
		 * Remove header `field`.
		 * Case-insensitive.
		 *
		 * Example:
		 *
		 *      req.get('/')
		 *        .unset('User-Agent')
		 *        .end(callback);
		 *
		 * @param {String} field
		 */
		exports.unset = function (field) {
			delete this._header[field.toLowerCase()];
			delete this.header[field];
			return this;
		};

		/**
		 * Write the field `name` and `val` for "multipart/form-data"
		 * request bodies.
		 *
		 * ``` js
		 * request.post('/upload')
		 *   .field('foo', 'bar')
		 *   .end(callback);
		 * ```
		 *
		 * @param {String} name
		 * @param {String|Blob|File|Buffer|fs.ReadStream} val
		 * @return {Request} for chaining
		 * @api public
		 */
		exports.field = function (name, val) {
			this._getFormData().append(name, val);
			return this;
		};

	}, { "./is-object": 19 }], 21: [function (require, module, exports) {
		// The node and browser modules expose versions of this with the
		// appropriate constructor function bound as first argument
		/**
		 * Issue a request:
		 *
		 * Examples:
		 *
		 *    request('GET', '/users').end(callback)
		 *    request('/users').end(callback)
		 *    request('/users', callback)
		 *
		 * @param {String} method
		 * @param {String|Function} url or callback
		 * @return {Request}
		 * @api public
		 */

		function request(RequestConstructor, method, url) {
			// callback
			if ('function' == typeof url) {
				return new RequestConstructor('GET', method).end(url);
			}

			// url first
			if (2 == arguments.length) {
				return new RequestConstructor('GET', method);
			}

			return new RequestConstructor(method, url);
		}

		module.exports = request;

	}, {}], 22: [function (require, module, exports) {

		/**
		 * Expose `Emitter`.
		 */

		if (typeof module !== 'undefined') {
			module.exports = Emitter;
		}

		/**
		 * Initialize a new `Emitter`.
		 *
		 * @api public
		 */

		function Emitter(obj) {
			if (obj) return mixin(obj);
		};

		/**
		 * Mixin the emitter properties.
		 *
		 * @param {Object} obj
		 * @return {Object}
		 * @api private
		 */

		function mixin(obj) {
			for (var key in Emitter.prototype) {
				obj[key] = Emitter.prototype[key];
			}
			return obj;
		}

		/**
		 * Listen on the given `event` with `fn`.
		 *
		 * @param {String} event
		 * @param {Function} fn
		 * @return {Emitter}
		 * @api public
		 */

		Emitter.prototype.on =
			Emitter.prototype.addEventListener = function (event, fn) {
				this._callbacks = this._callbacks || {};
				(this._callbacks['$' + event] = this._callbacks['$' + event] || [])
					.push(fn);
				return this;
			};

		/**
		 * Adds an `event` listener that will be invoked a single
		 * time then automatically removed.
		 *
		 * @param {String} event
		 * @param {Function} fn
		 * @return {Emitter}
		 * @api public
		 */

		Emitter.prototype.once = function (event, fn) {
			function on() {
				this.off(event, on);
				fn.apply(this, arguments);
			}

			on.fn = fn;
			this.on(event, on);
			return this;
		};

		/**
		 * Remove the given callback for `event` or all
		 * registered callbacks.
		 *
		 * @param {String} event
		 * @param {Function} fn
		 * @return {Emitter}
		 * @api public
		 */

		Emitter.prototype.off =
			Emitter.prototype.removeListener =
			Emitter.prototype.removeAllListeners =
			Emitter.prototype.removeEventListener = function (event, fn) {
				this._callbacks = this._callbacks || {};

				// all
				if (0 == arguments.length) {
					this._callbacks = {};
					return this;
				}

				// specific event
				var callbacks = this._callbacks['$' + event];
				if (!callbacks) return this;

				// remove all handlers
				if (1 == arguments.length) {
					delete this._callbacks['$' + event];
					return this;
				}

				// remove specific handler
				var cb;
				for (var i = 0; i < callbacks.length; i++) {
					cb = callbacks[i];
					if (cb === fn || cb.fn === fn) {
						callbacks.splice(i, 1);
						break;
					}
				}
				return this;
			};

		/**
		 * Emit `event` with the given args.
		 *
		 * @param {String} event
		 * @param {Mixed} ...
		 * @return {Emitter}
		 */

		Emitter.prototype.emit = function (event) {
			this._callbacks = this._callbacks || {};
			var args = [].slice.call(arguments, 1)
				, callbacks = this._callbacks['$' + event];

			if (callbacks) {
				callbacks = callbacks.slice(0);
				for (var i = 0, len = callbacks.length; i < len; ++i) {
					callbacks[i].apply(this, args);
				}
			}

			return this;
		};

		/**
		 * Return array of callbacks for `event`.
		 *
		 * @param {String} event
		 * @return {Array}
		 * @api public
		 */

		Emitter.prototype.listeners = function (event) {
			this._callbacks = this._callbacks || {};
			return this._callbacks['$' + event] || [];
		};

		/**
		 * Check if this emitter has `event` handlers.
		 *
		 * @param {String} event
		 * @return {Boolean}
		 * @api public
		 */

		Emitter.prototype.hasListeners = function (event) {
			return !!this.listeners(event).length;
		};

	}, {}], 23: [function (require, module, exports) {

		/**
		 * Reduce `arr` with `fn`.
		 *
		 * @param {Array} arr
		 * @param {Function} fn
		 * @param {Mixed} initial
		 *
		 * TODO: combatible error handling?
		 */

		module.exports = function (arr, fn, initial) {
			var idx = 0;
			var len = arr.length;
			var curr = arguments.length == 3
				? initial
				: arr[idx++];

			while (idx < len) {
				curr = fn.call(null, curr, arr[idx], ++idx, arr);
			}

			return curr;
		};
	}, {}]
}, {}, [1]);
